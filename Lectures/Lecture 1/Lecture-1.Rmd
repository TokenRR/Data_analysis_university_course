---
title: "Лекція 1. Вступ в аналіз даних та R"
author: "Данило Тавров"
date: "08.02.2023"
output:
  beamer_presentation:
    theme: Madrid
    toc: false
    colortheme: "seahorse"
    fonttheme: serif
    latex_engine: xelatex
    includes:
      in_header: "../latex/preamble.tex"
    highlight: tango
    incremental: true
    # df_print: kable
    # pandoc_args: ["--extract-media", "."]
    dev: cairo_pdf
fontsize: 9pt
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(kableExtra)

# custom function to make kable tables with smaller font sizes
kable <- function(data) {
  knitr::kable(data, booktabs = TRUE, digits = 2) %>% 
    kable_styling(font_size = 7)
}
```


# Силабус

## Викладач

- [Тавров Данило Юрійович](https://drive.google.com/file/d/1Gie_dJBuUOSO5uWzDE3tGSm4MbafimSx/view?usp=sharing)

- Освіта:
    + 2011: кафедра ПМА, бакалавр
    + 2013: кафедра ПМА, магістр
    + 2016: кафедра ПМА, канд. техн. наук
    + 2019: Київська школа економіки, магістр
    + 2022: University of California, Berkeley, магістр економіки

- Увесь час з 2013 р. з перервою на Берклі --- на кафедрі ПМА

- Контакти:
    + d.tavrov@kpi.ua
    + Slack: відповідаю в робочий час
    + Офісні години --- за домовленістю

## Де шукати матеріали до курсу

- Усі матеріали для курсу зібрано на [Google-диску](https://drive.google.com/drive/folders/1U_gVYael05LtkbwuNnlQ_tpfbeK3FurP?usp=share_link)

- Там будуть усі лекції та додаткові матеріали

- Усі заняття проходять у Zoom:
    + Лекції --- [за цим посиланням](https://us02web.zoom.us/j/9189174549?pwd=bTNWY1BnVkFLRFViTXVjbUUwTVFUQT09)
    + Презентація лабораторних робіт --- [за цим посиланням](https://zoom.us/j/3591803845?pwd=QjZoc2N2ZTV3NVZ0cjdJZjFVS0hWUT09)

## Структура курсу

- Вступ в аналіз даних, основи R

- Розвідковий аналіз даних (Exploratory data analysis, EDA)

- Основи статистичного виведення (statistical inference) за допомогою R (статистичні оцінки, тестування гіпотез, бутстреп (bootstrap))

- Регресійний аналіз

- Непараметричні методи (у т.ч. аналіз головних компонент (principle component analysis, PCA), вейвлет-аналіз)

- Беєсівське виведення (Bayesian inference)

- Основи причиново-наслідкового виведення (causal inference)

## Рейтингова система оцінювання

\begin{center}
	\begin{tabular}{p{4cm}p{4cm}cc}
		\toprule
		Вид роботи & Тематика & Дедлайн & Бали\\
		\midrule
		Лабораторна робота 0 & Вибір набору даних & 16.02.2023 & \\
		Лабораторна робота 1 & EDA & 02.03.2023 & 10 балів\\
		Лабораторна робота 2 & Статистичне виведення, бутстреп & 23.03.2023 & 10 балів\\
		Лабораторна робота 3 & Регресійний аналіз & 06.04.2023 & 10 балів\\
		Модульна контрольна робота & & 12.04.2022 & 40 балів\\
		Лабораторна робота 4 & Непараметричне виведення, PCA & 04.05.2023 & 10 балів\\
		Лабораторна робота 5 & Беєсівське виведення & 25.05.2023 & 10 балів\\
		Лабораторна робота 6 & Причиново-наслідкове виведення & 06.06.2023 & 10 балів\\
		\bottomrule
 	\end{tabular}		
 \end{center}

\vspace{0.5cm}

- Разом можна набрати 100 балів

- Якщо оцінка не подобається --- можна написати залік (1 теоретичне питання і 3 задачі)

- Умова **допуску до заліку** --- здано (і зараховано!) всі ЛР та написано МКР

- Умова **атестації** --- половина можливих балів

## Політика та контроль

- Обов'язковим є відвідання всіх лекцій

- Модульну контрольну роботу та залік кожний студент пише самостійно, консультування з третіми джерелами суворо заборонено

- За порушення правил академічної доброчесности під час МКР чи заліку будуть відповідні наслідки (анулювання результатів)

- Що стосується **лабораторних робіт**:
    + Усі лабораторні роботи виконуються на основі **одного й того ж** набору даних
    + Лабораторні роботи студенти виконують [мовою R](https://www.r-project.org/)
    + Лабораторні роботи виконуються **командами до 4 осіб включно**
    + По кожній роботі команда повинна здати **код**, **звіт** і **презентацію**
    + Самі презентації відбуваються **усно** на лабораторному занятті або за домовленістю
    + На захисті повинні бути присутні **всі** члени команди
    + Протягом семестру кожний член команди повинен виступити **принаймні тричі**
    + Презентації **записуються** та викладаються у **спільний доступ**
    + На їх основі будуть формулюватися **питання МКР**

## Поради щодо вивчення курсу

- Це не є курс програмування на R!

- R --- це просто *один із* можливих інструментів для аналізу даних (поряд із Python, MATLAB, Stata тощо)

- Із таким же успіхом можна було б вичитати цей курс на будь-якій із цих альтернатив

- Студенти, які вже вивчили Python та інші мови програмування, можуть опанувати R дуже швидко

- «Аналіз даних» --- доволі розмите поняття, тому наповнення курсу може бути зовсім різне

- Я пропоную своє бачення, що важливо розглянути

# Вступ в аналіз даних

## Життєвий цикл аналізу даних (Data Science lifecycle) (1)

-   Одна з популярних версій життєвого циклу аналізу даних ^[https://r4ds.had.co.nz/explore-intro.html]:

```{r, indent = "    ", echo = FALSE, out.width = '70%', fig.align = 'center', fig.cap = ''}
knitr::include_graphics('images/data_science_workflow.png')
```

- На самому початку потрібно з'ясувати, **що** і **з якою метою** будемо досліджувати

- Потім потрібно **зібрати відповідні дані**

- Дані потрібно **імпортувати** (з файлу, бази даних, через Інтернет тощо)

- Після цього дані потрібно **почистити** та **перетворити**
    + Реструктуризація даних для приведення їх в охайний вигляд
    + Видалення непотрібних рядків і стовпців
    + Перейменування, перекодування і т.п.
    + Це часто є найдовший і найнудніший, але гранично важливий етап
    + Його часто називають **data wrangling** (дослівно «суперечка з даними»)

## Життєвий цикл аналізу даних (Data Science lifecycle) (2)

-   Одна з популярних версій життєвого циклу аналізу даних ^[https://r4ds.had.co.nz/explore-intro.html]:

```{r, indent = "    ", echo = FALSE, out.width = '70%', fig.align = 'center', fig.cap = 'Життєвий цикл аналізу даних'}
knitr::include_graphics('images/data_science_workflow.png')
```

- Після попередньої підготовки даних їх можна **візуалізувати**
    + Корисно для формування гіпотез для дальшої статистичної перевірки
    + Важливо для оформлення результатів аналізу даних у звітах та презентаціях
    
- На основі теорії, попереднього аналізу даних чи їх візуалізації можна будувати **моделі** (статистичні, так чи інакше), які описують ці дані
    + Цьому в основному й присвячено конкретно **наш курс**

- Усі результати аналізу даних потрібно правильно **скомунікувати** у вигляді звіту, презентації тощо
    + Цим ви займатиметеся в рамках підготовки до захисту своїх **лабораторних робіт**

## Як ставити дослідницьке питання

- Для проведення доброго аналізу даних потрібно думати більше, ніж робити

- Особливо важливо правильно сформулювати дослідницьке питання

- Характеристики доброго дослідницького питання:
    + Воно повинно становити **цікавість** для авдиторії (природа якої залежить від контексту)
    + Воно не повинно мати відповідей у літературі
    + Воно повинно спиратися на здоровий глузд
    + Відповідь на нього можна дістати (як у гіпотетичному сенсі, так і з практичних міркувань на кшталт наявности даних)
    + Воно повинно бути конкретизовано настільки, щоб на нього можна було дістати вичерпну відповідь 

- Нарешті, потрібно заздалегідь передбачати, якого роду відповіді на питання можуть бути, і як їх інтерпретувати

- Розгляньмо основні типи питань, які можуть виникнути

## Типи питань в аналізі даних (1)

- Розгляньмо види аналізу даних, які можуть виринати на практиці ^[Leek J. T., Peng R. D. What is the question? Science 347(6228), pp. 1314--1315 (2015). https://www.science.org/doi/abs/10.1126/science.aaa6146]


```{r, indent = "    ", echo = FALSE, out.width = '70%', fig.align = 'center', fig.cap = ''}
knitr::include_graphics('images/questions.png')
```


## Типи питань в аналізі даних (2)

- **Описовий** (descriptive): збір чи підрахунок загальних показників без жодних додаткових інтерпретацій чи пояснень
    + Наприклад, перепис населення, на основі якого можна порахувати населення кожного регіону

- **Розвідковий** (exploratory): пошук трендів, кореляцій, асоціацій тощо між різними змінними з метою формулювання гіпотез, які ще потрібно перевірити

- **Інференційний** (inferential): кількісне вимірювання того, наскільки помічений у даних шаблон повторюватиметься в інших наборах даних
    + Фактично мова про оцінку невідомих статистичних параметрів даних для всієї популяції
    + Найпоширеніший тип аналізу в статистиці та економетриці

## Типи питань в аналізі даних (3)

- **Прогнозний** (predictive): на основі наявних даних хочемо не просто оцінити параметри деякої модели, що їх породила, а й спрогнозувати нові значення з цієї модели
    + Часто відповідні моделі не дають розуміння, *чому саме* вона правильно прогнозують нові значення
    + Ви їх будете розглядати в рамках машинного навчання

- **Причиново-наслідковий** (causal): ми намагаємося з'ясувати не просто кореляційний зв'язок між деякими змінними, а яка змінна як впливає на інші
    + Оскільки дані мають статистичний характер, ми можемо встановити прямий зв'язок тільки в середньому
    + Сам дизайн експерименту може свідчити, що інтерпретація буде казуальною
    + Наприклад, якщо дані було зібрано в рамках рандомізованого контрольованого випробування (randomized controlled trial, RCT)
    + В окремих випадках (інженерні задачі тощо), причиново-наслідковий зв'язок можна встановити однозначно (**механістичний** (mechanistic) аналіз даних)

## Неправильна інтепретація видів аналізу

- Розгляньмо типові помилки неправильного визначення природи дослідницького питання ^[Leek J. The Elements of Data Analytic Style: A guide for people who want to analyze data. Leanpub (2015)]

- Видавання інференційного аналізу за причиново-наслідковий
    + Також відоме під назвою «Correlation does not imply causation»
    + Приклади відомих безглуздих кореляцій наведено  [тут](http://tylervigen.com/) і [тут](https://www.buzzfeednews.com/article/kjh2110/the-10-most-bizarre-correlations)

- Видавання розвідкового аналізу за прогнозний
    + Це тісно пов'язано з поняттям **overfitting** (перенавчання)
    + Увесь набір даних використовують для побудови модели та її оцінювання
    + Не розбивають на навчальний та тестовий набори

- Видавання дескриптивного та розвідкового аналізу за інференційний 
    + Те, що має місце в одній вибірці, вважають характерним для всієї популяції
    + Якщо на одному наборі будувати багато різних моделей, одна з них суто випадково може показати гарний результат
    + За влучним виразом економіста Рональда Коуза (Ronald Harry Coase, 1910--2013), «Якщо мучити дані достатньо довго, природа в усьому зізнається»

## Які можуть бути проблеми з даними (1)

- Вибірка дуже мала
    + Що більше даних, то точніші статистичні оцінки
    + Якщо даних багато, застосовні методи асимптотичної теорії, справедлива центральна гранична теорема
    + Для малих вибірок потрібно застосовувати спеціальні статистичні методи
    + У цьому курсі нас цікавлять тільки **дуже великі** вибірки

- Немає всіх потрібних змінних, замість яких використовують **проксі-змінні** (proxy variables)
    + Потрібно оцінити вплив якости життя на народжуваність, але наявні тільки дані про ВВП
    + Потрібно знайти зв'язок між здібностями людини та її доходами, але маємо тільки її оцінки в школі
    + Потрібно з'ясувати вплив куріння на рак легень, але маємо тільки акцизні збори в деякому районі

## Які можуть бути проблеми з даними (2)

- У вибірці відсутні змінні, які можуть бути **конфаундерами** (confounders)
    + Конфаундер впливає одночасно на декілька змінних, і тому видимий зв'язок між ними є хибним
    + Дані можуть свідчити про (додатний) зв'язок уживання алкоголю і раку легень, але причина може бути в тому, що ми не враховуємо куріння
    + Дані можуть свідчити про (від'ємний) зв'язок між рівнем фізичної активности і інфарктом, але причина може бути в тому, що вища активність притаманна молоді

- Дані вибірки не є репрезентативні
    + В ідеалі, у репрезентативній вибірці частка спостережень із певними характеристиками повинна приблизно дорівнювати ймовірності зустріти їх у популяції
    + Якщо вибірка нерепрезентативна, результати аналізу не можуть бути показові для всієї популяції (страждає **зовнішня валідність** (external validity) аналізу)
    + Ми маємо справу з **систематичною похибкою відбору** (selection bias), яку потрібно враховувати спеціальними методами
    + (Чи можна довіряти дослідженням, у яких респонденти **за своїм бажанням** заповнюють анкети?)
    + В окремих випадках можна надати різним спостереженням різної ваги, щоб компенсувати непропорційність їх представлення
    
- У нашому курсі ви працюватимете з достатньо великими наборами даних, щоб усі ці нюанси було мінімізовано

## Приклад формулювання дослідницького питання (1)

- Розгляньмо приклад аналізу даних компанії-виробника фітнес-трекерів на предмет виявлення цільової авдиторії для реклами трекера сну ^[Peng R., Matsui E. The Art of Data Science. Leanpub (2016)]

- У базі даних наявна така інформація: основні демографічні параметри, кількість кроків за день,
 кількість клітин сходів за день, кількість сидячих годин за день, кількість годин бадьорости та сонливости за день, кількість годин сну за день

- Зазначена мета дослідження не є достатньо конкретною, тому дослідник у спілкуванні з керівництвом формулює деталізованіше питання: *«Які клієнти компанії недосипають?»*

- Дослідник повинен переконатися, що питання відповідає всім критеріям доброго питання
    + Воно становить цікавість для керівництва
    + Воно, **певно**, не має відповідей у літературі (інакше керівництво не замовило б це дослідження, хоча воно може помилятися!)
    + Воно спирається на здоровий глузд: клієнти, що недосипають, можуть бути зацікавлені в трекері сну
    + ... Але що вважати недосипом?

## Приклад формулювання дослідницького питання (2)

- Після спілкування з фахівцями, дослідник усвідомлює, що ліпше аналізувати не кількість сну, а сонливість протягом дня

- Отже питання дістає нове формулювання: *«Які клієнти компанії страждають на сонливість протягом дня?»*

- На щастя, наявні дані дають змогу дати відповідь на таке питання

- Але питання недостатньо конкретизовано

- У спілкуванні з колегами дослідник визнає, що потрібно чіткіше сформулювати, що значить «які клієнти», що таке «сонливість протягом дня» (скільки саме?)

- Остаточне формулювання звучить так: *«Які демографічні та медичні характеристики описують клієнтів, які страждають на хронічну сонливість, визначену як щонайменше один епізод сонливости щонайменше кожного другого дня?»*

- Дослідник очікує два можливі результати аналізу:
    + Жодних особливих характеристик виявлено не буде
    + **Інтерпретація**: таргетована реклама не матиме сенсу
    + Буде знайдено характеристики, що пов'язані з сонливістю
    + **Інтерпретація**: можна буде таргетувати рекламу для клієнтів із такими характеристиками

## Приклад формулювання дослідницького питання (3)

- Наостанок дослідник повинен з'ясувати, якого типу його питання

- Це дасть змогу зрозуміти, які методи аналізу ліпше використати

- На перший погляд може здатися, що питання має розвідковий характер
    + Потрібно подивитися, які існують зв'язки між різними змінними
    + Оскільки ми працюємо з клієнтами однієї компанії, нас не дуже цікавить, чи матиме місце цей зв'язок у всій популяції (тому точно не інференційний)

- Проте у компанії можуть з'являтися нові клієнти, і тому було б корисно таргетувати рекламу і для них також

- Відтак питання носить **прогнозний** характер

- Тому для відповіди на нього потрібно будувати моделі для прогнозування

# Основи програмування в R

## Вступні зауваги

- Короткий огляд мови R не ставить на меті дати вичерпний аналіз її можливостей

- Це набір окремих типових прикладів

- Докладну інформацію можна дістати з книжки [*R for Data Science*](https://r4ds.had.co.nz/) (PDF версія доступна на диску)
    + Особливо корисні в першому читанні розділи 4, 5, 6, 10--11 (по діагоналі), 12, 19, 20

- Інші корисні книжки:
    + [Cookbook for R](http://www.cookbook-r.com/): набір конкретних поширених прикладів
    + [Hands-On Programming with R](https://rstudio-education.github.io/hopr/)
    + Українською можна почитати розділи 1--2 у [підручнику Р. Майбороди](https://probability.knu.ua/userfiles/mre/compsta1.pdf)
    + Та подивитися відео з двох плейлистів: [І. Мірошниченка](https://www.youtube.com/playlist?list=PLWL2vVyKljMPHHIOQ-ArCwIoUfvVrvH_a) та [AGMEMOD](https://www.youtube.com/playlist?list=PLugcTYn0bBjLXbhCHWQvbY8FCGi2AeKJG)

- Додаткову докладну інформацію можна дістати зі шпаргалок (cheat sheets) за [посиланням](https://posit.co/resources/cheatsheets/), їх також викладено на диск

- Також завжди можна звернутися до сайтів [Stack Overflow](https://stackoverflow.com/) та [Stack Exchange](https://stackexchange.com/)

## Що таке R

- R --- це мова та середовище програмування для статистичного аналізу даних та їх візуалізації ^[https://www.r-project.org/about.html]

- R є некомерційним і вільно розповсюджується за ліцензією GNU General Public Licens

- Чому саме R?
    + Щоб студенти володіли ще одним інструментарієм
    + R заточено саме під статистичний аналіз даних, на відміну від того ж Python, який має ширшу екосистему для машинного навчання
    + Детальніше про відповідні порівняння можна почитати [тут](https://www.dataquest.io/blog/python-vs-r/) і [тут](https://posit.co/blog/r-vs-python-what-s-the-best-for-language-for-data-science/)
    + «Словнички» між R та Python можна подивитися [тут](https://github.com/SrihariPramod/R_vs_Python_Cheatsheet/blob/master/R_vs_Python.pdf) і [тут](https://github.com/yl3738/Python-vs.-R-Cheatsheet/blob/main/community%20contribution_CC%20group14.pdf)

 <!-- - Пакет `tidyverse` надає потужні можливості для опрацювання та візуалізації даних -->

## Установлення R, RStudio та важливих пакетів

- Для початку роботи з R його потрібно встановити

- Скачати інсталятор можна з сайту [CRAN](https://cran.r-project.org/) (The Comprehensive R Archive Network)

- Для зручної роботи в R потрібно встановити IDE (integrated development environment), яким у випадку R поза конкуренцією є [RStudio](https://rstudio.com/)

- Як і в Python, значну частину корисних функцій (а також наборів даних та файлів допомоги) реалізовано в **пакетах** (packages), які потрібно встановлювати окремо

- Інсталювати пакети можна або за допомогою інтерфейсу в RStudio, або безпосередньо функцією `install.packages`

- Нам відразу знадобиться пакет `tidyverse`, який можна встановити викликом `install.packages("tidyverse")`

- Інші пакети, які реалізують методи аналізу даних, які ми вивчатимемо далі, інсталюватимемо окремо

## Базові операції (1)

- Аритметичні операції:
```{r arithmetic, indent = "    "}
2 + 2
(2 - 2) * 3
2 / (2 ^ 3)
sin(pi / 2)
log(exp(1))
```

## Базові операції (2)

- Логічні операції:
```{r logical, indent = "    "}
0.5 == sqrt(0.25)
5 != (10 / 2)
2 + 3 > 4
5 - 2 < sin(2)
3 >= 10 / 3
1 <= 1 + pi
sqrt(2) ^ 2 == 2
dplyr::near(sqrt(2) ^ 2, 2)
TRUE | FALSE
TRUE & FALSE
```

## Змінні

- Як і в інших мовах, в R можна створювати **змінні** (variables)
```{r variables, indent = "    "}
a <- 2 + 2
```

- Назви повинні починатися з літер і повинні містити тільки літери, цифри, `_` та `.`

- Існують різні стилі називання змінних: `snake_case`, `camelCase`, або з точками як у `this.function`

- Для виведення вмісту на екран треба просто вказати назву змінної:
```{r, indent = "    "}
a
```

## Вектори (1)

- R --- мова, у якій більшість функцій векторизовані

- Створити **вектор** (vector) можна за допомогою функції `c`

- Типи векторів, які нас цікавлять:

    + **дійсні** (double):
```{r double, indent = '        '}
vec_num <- c(1.1, 2.3, -0.4)
vec_num
typeof(vec_num)
```

    + **цілочисельні** (integer):
```{r integer, indent = '        '}
vec_int <- c(1, 2, 3)
typeof(vec_int)
```

```{r, indent = '        '}
vec_int <- c(1L, 2L, 3L)
typeof(vec_int)
```

    + **логічні** (logical):
```{r logical_vec, indent = '        '}
vec_logic <- c(TRUE, FALSE, TRUE)
typeof(vec_logic)
```

    + **символьні** (character):
```{r character, indent = '        '}
vec_char <- c("Hello", "world", "!")
typeof(vec_char)
```

## Вектори (2)

- В R переважна більшість функцій є векторизована:
```{r vec_funcs, indent = "    "}
vec_num <- c(1.1, 2.3, -0.4)
cos(vec_num)
exp(vec_num)
vec_num * vec_int
```

- Якщо один вектор коротший, то він повторюватиметься циклічно (т.зв. **recycling**)
```{r vec_funcs_recycling, indent = "    "}
a <- 1:10
b <- -5:-1
a + b
```

- Це особливо корисно, якщо один із операндів --- скаляр (фактично вектор довжини 1)

- Дуже зручно утворювати індексні вектори
```{r vec_index, indent = "    "}
a + b > 0
```

## Спеціальні значення

- Існує спеціальне **логічне** значення `NA` (not available), яке відповідає **пропущеним даним**
```{r na, indent = "    "}
NA > 5
NA == 5
NA + 5
NA == NA
```

- Для перевірки на відсутність застосовуємо функцію `is.na`

- Для дійсних значень також можливі спеціальні значення `Inf` (infinity) та `NaN` (not a number, невизначеність)
```{r nan, indent = "    "}
c(-1, 0, 1) / 0
```

- Для перевірки на нескінченність застосовуємо функції `is.finite`, `is.infinite`

- Для перевірки на невизначеність застосовуємо функцію `is.nan`
```{r is.nan, indent = "    ", warning = FALSE}
is.finite(4 / 0)
is.nan(Inf - Inf)
is.nan(log(-1))
```

## Індексація векторів (1)

- Індексація векторів в R починається з 1
```{r index_start_from_1, indent = "    "}
vec <- 10:1
vec[1]
```

- Індексувати можна індексним вектором
```{r indexing_with_vectors, indent = "    "}
vec[c(1, 4, 6)]
vec[vec %% 2 == 0]
vec[(vec > 3) & (vec < 7)]
```

- Можна явно вказувати, які елементи викинути
```{r indexing_with_vectors_neg, indent = "    "}
vec[-c(1, 4, 6)]
```

## Індексація векторів (2)

- Елементам вектора можна присвоїти імена
```{r vec_names, indent = "    "}
vec <- 1:3
names(vec) <- c("a", "b", "c")
vec
```

- Тоді індексацію можна робити також і за іменами
```{r vec_names_indexing, indent = "    "}
vec[c("a", "c")]
```

- Індексацію можна використовувати для внесення змін у вектор
```{r indexing_left, indent = "    "}
vec <- 1:10
vec[vec > 5] <- 2
vec
```

## Фактори

- Для моделювання **категорійних змінних** (categorical variables) в R застосовують спеціальний вид вектора --- **фактор** (factor)

- Фактично це є цілочисельний вектор, але числа кодують окремі категорії (levels)
```{r months1, indent = "    "}
months <- c(
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
months_factor <- factor(months, levels = months)
months_factor
levels(months_factor)
```

- Можна створити вектор і з частиною категорій
```{r months2, indent = "    "}
factor(c("Dec", "Jan", "Feb"), levels = months)
```

- Використання факторів унеможливлює описки, дає можливість сортувати категорії та спрощує роботу з ними

## Приведення типів (1)

- Вектори можна об'єднувати
```{r vec_c, indent = "    "}
a <- 1:3
c(a, a, a)
```

- Об'єднання векторів різних типів веде до неявного приведення типів
```{r coercion, indent = "    "}
typeof(c(TRUE, 1L))
typeof(c(1L, 1.5))
typeof(c(1.5, "a"))
```

- Неявне приведення типів зручно використовувати, щоб рахувати число чи частку елементів
```{r coercion_mean, indent = "    "}
x <- c(4, 10, 2, 7, 4, 9)
sum(x > 5)  # скільки чисел перевищує 5
mean(x <= 5)  # частка чисел, не більших 5
```

## Приведення типів (2)

- Приведення типів можна виконати явно
```{r coercion_explicit, indent = "    ", warning = FALSE}
vec <- c(1, 0, 1, 0)
as.character(vec)
as.logical(vec)
vec2 <- c("2", "3.4", "TRUE")
as.numeric(vec2)
vec3 <- c("a", "b")
as.double(vec3)
```

- Також можна явно привести вектор до фактора
```{r coercion_factor, indent = "    "}
as.factor(c(1, 2, 3, 2, 3, 1))
```

## Рядки (1)

- Як і в інших мовах, **рядок** (string) в R --- це послідовність символів

- Їх можна створювати і одинарними, і подвійними лапками:
```{r string1, indent = "    "}
string1 <- "Hello world!"
string2 <- 'Hello "world"!'
```

- Окремі символи потрібно **екранувати** (escape) за допомогою `\`:
```{r string2, indent = "    "}
c("\"", "\\", "\n", "\t")
```

- Базовий пакет R містить функції для роботи з рядками, але сучасний підхід полягає у застосуванні функцій із пакету `stringr` (складова пакета `tidyverse`)

- Довжина
```{r string3, indent = "    "}
str_length(c("a", "Data analysis", NA))
```

- Конкатенація
```{r string4, indent = "    "}
str_c("a", "b")
str_c("a", "b", sep = ", ")
str_c("pref-", c("1", NA, "2"), "-suff")
str_c("pref-", str_replace_na(c("1", NA, "2")), "-suff")
```

## Рядки (2)

- Виділення підрядка
```{r string5, indent = "    "}
x <- c("Яблуко", "Банан")
str_sub(x, 1, 3)
str_sub(x, -3, -1)
str_sub(x, 1, 6)
```

- Зміна регістра
```{r string6, indent = "    "}
x <- c("ЯбЛуко", "БанАН")
str_to_lower(x)
str_to_upper(x)
str_to_title(x)
```

- Сортування
```{r string7, indent = "    "}
x <- c("Ієремія", "Артем", "Яків")
str_sort(x)
```

## Списки (1)

- **Списки** (lists) в R використовують для зберігання різнотипних даних

- Для перегляду їхньої структури корисною є функція `str`
```{r list1, indent = "    "}
list_exmp <- list(
    "list_1" = list("a", 1L, 1.5, TRUE),
    "list_2" = list(Jan = 1, Feb = 2, Mar = 3),
    "list_3" = 3
)
str(list_exmp)
```

## Списки (2)

- Індексування списків можна робити в декілька способів

- За допомогою `[]` можна дістати **список**
```{r list2, indent = "    "}
list_exmp[1:2]
list_exmp[3]
```

## Списки (3)

- За допомогою `[[]]` можна дістати **елемент списку**
```{r list3, indent = "    "}
list_exmp[[2]]
```

- `$` працює аналогічно, але особливо корисно для йменованих елементів
```{r list4, indent = "    "}
list_exmp$list_2$Feb
```

## Функції в R (1)

- R --- багато в чому функціональна мова, пакетів із функціями величезна кількість

- Числові операції з векторами
```{r funcs1, indent = "    "}
vec <- c(-3, 0, 5, 5, -3, 8)
sum(vec)
max(vec)
min(vec)
median(vec)
mean(vec)
sd(vec)  # середньоквадратичне відхилення
summary(vec)  # максимум, мінімум, сподівання і квартилі
vec_na <- c(NA, 1, 2)
mean(vec_na)
mean(vec_na, na.rm = TRUE)
```

## Функції в R (2)

- Маніпуляції з векторами
```{r funcs2, indent = "    "}
length(vec)
sort(vec)
unique(vec)
rev(vec)  # задом наперед
table(vec)  # скільки яких елементів
```

- Генерування векторів
```{r funcs3, indent = "    "}
seq(1, 5)
seq(1, 5, by = 2)
rep("a", 5)
rep(FALSE, 5)
```

## Функції в R (3)

- Синтаксис для написання власних функцій:
```{r func1, indent = "    "}
add <- function(x, y){
    x + y
}

add(2, 3)
```

- `{` ніколи не може бути першою в рядочку, за нею завжди повинен починатися новий рядок

- `}` завжди повинен стояти на окремому рядку

- Завжди потрібно робити відступи

- За замовчуванням повертають результат останнього рядка

- Щоб явно вказати, що повертають, потрібно використати `return`

```{r func2, indent = "    "}
add_and_subtract <- function(x, y){
    a <- x + y
    b <- x - y
    return(list("sum" = a, "diff" = b))
}

add_and_subtract(2, 3)
```

## Функції в R (4)

- Іменовані аргументи
```{r func3, indent = "    "}
zero_out <- function(vec, threshold){
    vec[abs(vec) > threshold] <- 0
    return(vec)
}

zero_out(c(1, 2, 3), 2)
zero_out(c(1, 2, 3), threshold = 2)
```

- Значення за замовчуванням

```{r func4, indent = "    "}
zero_out <- function(vec, threshold = 1){
    vec[abs(vec) > threshold] <- 0
    return(vec)
}

zero_out(c(1, 2, 3))
zero_out(c(1, 2, 3), threshold = 2)
```

- В окремих функціях може бути нефіксована кількість аргументів

- Наприклад, `sum` має сигнатуру `sum(..., na.rm = FALSE)`

- Тому можна викликати і `sum(1, 2, 3)`, і `sum(1:5)` тощо

## Функції в R: корисні поради

- Ім'я функції повинно бути коротким, але змістовним

    + `remove_outliers` --- ліпше, ніж `rem_out`

- Варто притримуватися однакового стилю в іменуваннях

    + `remove_outliers` не може йти поряд з `removeMissingValues`

- Для функцій із однієї сім'ї потрібно використовувати однаковий префікс

    + `remove_outliers`, `remove_na`, `remove_typos` --- OK

    + `outliers_remove`, `na_remove`, `typos_remove` --- не ОК!

- Потрібно бути дуже акуратним, щоб випадково не перевизначити базові речі в R, написавши щось типу `c <- 10`

- Не забувайте рясно коментувати код: початок коментаря позначає символ `#`

- Імена аргументів:

    + `x`, `y`, `z`: вектори

    + `w`: вектор вагових коефіцієнтів

    + `df`: датафрейм (розглядатимемо далі)

    + `i`, `j`: індекси (як правило, рядок і стовпець)

    + `n`: довжина вектора або число рядків

    + `p`: число стовпців

## Умовний оператор (1)

- Як і в інших мовах, умовне виконання коду можна досягти за допомогою виразу `if`

```{r if1, indent = "    "}
x <- 2
if (x > 0) {
    y <- sqrt(2)
} else {
    y <- 0
}

y
```

- `{` ніколи не може бути першою в рядочку, за нею завжди повинен починатися новий рядок

- `}` завжди повинен стояти на окремому рядку, якщо тільки за ним не йде `else`

- Для складних умов можна використовувати логічні оператори `&&` (і), `||` (чи)

- Завжди потрібно робити відступи

- Умова повинна бути скалярною

- `==` векторизована, тому порівняння вектора зі скаляром дасть вектор

- Ліпше використовувати `all()` та `any()`

```{r if2, indent = "    "}
x <- c(1, 0, 0)
if (any(x == 0)){
    "Є нульові елементи"
} else {
    "Немає нульових елементів"
}
```

## Умовний оператор (2)

- Якщо умов декілька, можна використовувати або вкладені оператори
```{r if3, indent = "    "}
if (all(x == 0)) {
    "Усі елементи нульові"
} else if (any(x == 0)) {
    "Деякі елементи нульові"
} else {
    "Немає нульових елементів"
}
```

- ...або фукнцію `switch()`
```{r switch, indent = "    "}
centre <- function(x, type) {
    switch(type,
        mean = mean(x),
        median = median(x)
    )
}

x <- c(-1, -1.8, 0.9, -0.4, -0.8, -.1, 1.2, 1.3)
centre(x, "mean")
centre(x, "median")
```

## Цикли

- Як і в інших мовах, R підтримує цикли `for` і `while`
```{r for, indent = "    "}
x <- c(1, 2, 3, 4, 5)
for (i in seq_along(x)) {  # те саме, що й "i in 1:length(x)"
    x[i] <- x[i] * 2
}
```

- Але такі цикли зовсім непритаманні R, адже ця мова дуже векторизована

- Значно швидше і зрозуміліше було б написати `x <- 2*x`

- Те саме стосується і складніших структур даних

- Функції можна застосовувати до всіх елементів векторів, списків і т.п. за допомогою спеціальних функцій, наприклад, `lapply`
```{r lapply, indent = "    "}
lapply(list_exmp, length)
```

## Датафрейми (1)

-   **Датафрейм** (dataframe) --- це фактично список, але з певними обмеженнями

-   У датафреймі всі елементи мають різні назви та є векторами однакової довжини

-   Тобто фактично датафрейм є таблицею даних різних типів, де стовпці відповідають **змінним** (variables), а рядки --- **спостереженням** (observations)

-   Створити датафрейм можна, явно вказавши дані, які в ньому містяться

```{r df1, indent = "    "}
df <- data.frame("height" = c(170, 172, 168, 182), "weight" = c(71, 85, 70, 92))
df
```

## Датафрейми (2)

-   Оскільки це список, окремі стовпці можна дістати за назвою

```{r df2, indent = "    "}
mean(df$weight)
median(df$height)
```

-   Індексацію також можна робити за індексами

```{r df3, indent = "    "}
df[3, 2]  # третій рядок, другий стовпець
df[1, ]  # весь перший рядок
df[, 2]  # весь другий стовпець
df[2:4, 1:2]  # рядки 2--4 з обох стовпців
```

-   Така індексація не дуже зручна і не дуже прозора

## Деякі операції з датафреймами (1)

-   Розмірність датафрейма

```{r df4, indent = "    "}
dim(df)
nrow(df)
ncol(df)
```

-   Структура датафрейма

```{r df5, indent = "    "}
str(df)
names(df)  # аналогічно colnames
```

## Деякі операції з датафреймами (2)

-   Виведення на екран перших і останніх рядків

```{r df6, indent = "    "}
head(df)
tail(df)
```

## Додавання нових змінних

-   Додавання нових змінних з іншого датафрейма

```{r df7, indent = "    "}
df2 <- data.frame(age = c(35, 32, 33, 34))
df_new <- cbind(df, df2)
df_new
```

-   Додавання нового стовпця

```{r df8, indent = "    "}
df_new$sex <- c(1, 1, 0, 0)
df_new
```

-   Нас ці та інші маніпуляції мало цікавитимуть, оскільки ми будемо працювати з сучасною версію датафреймів --- так званими **тиблами** (tibbles) з пакету `tidyverse`

# Робота з `tidyverse`

## Що таке tidy data («охайні дані»)

-   Автор цього поняття --- Гедлі Вікем (Hadley Wickham), який і розробив основні пакети з `tidyverse`

-   Повну відповідь на це питання можна знайти в [цій статті](https://www.jstatsoft.org/index.php/jss/article/view/v059i10/772) (також викладена на диск)

-   Якщо коротко, то дані можна подати в різний спосіб

-   Охайні дані є прямокутними, і до того ж:
    +   Кожній **змінній** (variable) відповідає окремий стовпець
    +   Кожному **спостереженню** (observation) відповідає окремий рядок
    +   Кожне окреме **значення** (value) зберігається в окремій комірці
\visible<+->{
```{r tidy, indent = "        ", echo = FALSE, out.width = '80%', fig.align = 'center', fig.cap = ''}
knitr::include_graphics('images/tidy.png')
```
}

## Приклади організації даних (1)

-   Розгляньмо декілька прикладів організації даних із пакету `tidyr`

```{r table1, indent = "    "}
table1
```

-   Цей набір даних є охайним

-   Кожній змінній (країна, рік, кількість випадків, населення) відповідає свій стовпець

-   Кожному спостереженню (унікальна пара (країна, рік)) --- окремий рядок

## Приклади організації даних (2)

-   Інший варіант:

```{r table2, indent = "    "}
table2
```

-   Тут стовпець `type` не є самостійною змінною, а містить назви двох змінних `cases`, `population`

-   Значення цих змінних розміщено в окремому стовпці `count`

## Приклади організації даних (3)

-   Інший варіант:

```{r table3, indent = "    "}
table3
```

-   Цей варіант не є охайним, тому що два показники --- число випадків і загальна кількість населення --- стиснуто в одному стовпці

## Приклади організації даних (4)

-   Інший варіант:

```{r table4, indent = "    "}
table4a
table4b
```

-   Цей варіант не є охайним, бо для подання одного набору даних використано два датафрейми

-   У кожному датафреймі стовпці відповідають окремим рокам

-   Хоча змінною повинно бути не, напр., «Населення в 1999 р.», а просто «Населення»

-   Такого роду подання даних можуть бути корисні для публікацій в різних звітах, але зовсім некорисні для роботи з ними та аналізу

## Робота з охайними даними

-   Нас у цьому курсі не так сильно цікавить, як саме приводити дані до охайного вигляду

-   Зрештою, це не так складно робити і за потреби можна освоїти самостійно

-   Цікаву інформацію можна дістати з [розділу *R for Data Science*](https://r4ds.had.co.nz/tidy-data.html) та [інших джерел](https://tidyr.tidyverse.org/articles/tidy-data.html)

-   Нас більше цікавить, як можна працювати з охайними даними за допомогою засобів пакету `tidyverse`

-   Додаткову інформацію про можливості цього пакету можна дізнатися [на офіційному сайті](https://tidyr.tidyverse.org/)

## Приклад

-   Як конкретний приклад розгляньмо [дані про пасажирів Титаніку](https://www.kaggle.com/competitions/titanic/data), описаний [тут](https://www.datacamp.com/tutorial/tidyverse-tutorial-r)

- Після скачування відповідного файлу формату CSV (comma separated values) та розміщення у відповідному каталозі, ми його зчитуємо
```{r tidyverse1, indent = "    "}
passengers <- read_csv("data/titanic.csv")
passengers
```

- В описах стовпців можемо зустріти `int` (цілі числа), `dbl` (дійсні числа), `chr` (рядки), `lgl` (логічні), `fctr` (фактори), `dttm` (дата і час) та `date` (дата)

## Відбір рядків за певними критеріями

- Якщо ми хочемо виокремити певну підмножину спостережень, то потрібно використати функцію `filter()`

- Аргументами повинні стати критерії, за якими потрібно здійснювати відбір

- Критерії можна конкатенувати за допомогою логічних операцій, а можна перелічити через кому
```{r tidyverse2, indent = "    "}
passengers %>% filter(Sex == "female")
```

- Ми відібрали всіх жінок

- Можна помітити тенденцію, що серед жінок більшість вижили: це варто додаткового аналізу

- Результат відбору можна за потреби записати в окрему змінну, початкові дані при цьому не змінюються

## Сортування рядків за певними критеріями (1)

- Якщо ми хочемо сортувати дані за певними критеріями, то потрібно використати функцію `arrange()`

- Аргументами повинні стати назви стовпців, за якими потрібно сортувати

- Можна вказувати декілька стовпців: тоді спочатку відбуватиметься сортування за першим, далі --- за другим тощо
```{r tidyverse3, indent = "    "}
passengers %>% arrange(Fare, Age)
```

- Ми відсортували всіх пасажирів за вартістю квитка, а у випадку однакової вартости --- ще й за віком

- Можна помітити, що пасажири з малою вартістю квитка, як правило, не вижили

## Сортування рядків за певними критеріями (2)

- За замовчуванням сортування йде за зростанням

- Для сортування в спадному порядку, потрібно додати функцію `desc`
```{r tidyverse4, indent = "    "}
passengers %>% arrange(desc(Fare), Age)
```

- Справді на перший погляд уцілілих більше серед заможних пасажирів

- Варто зазначити, що пропущені значення `NA` завжди сортуються останні, незалежно від напрямку сортування! 

## Додавання нових змінних

- Дуже часто в аналізі даних (і в машинному навчанні) потрібно створювати нові змінні

- Це часто є етапом попередньої підготовки даних, коли з існуючих стовпців потрібно утворити ті, які мають більший сенс

- Часто це потрібно робити на етапі самого аналізу для утворення нових змінних (напр., логаритмування чи піднесення до квадрату тощо)

- Для утворення нових змінних потрібно використати функцію `mutate()`

- Аргументами повинні стати пари *новий стовпець*--*функція від старих стовпців*
```{r tidyverse5, indent = "    "}
passengers %>% mutate(FamSize = Parch + SibSp)
```

- Ми додали новий стовпець `FamSize` (кількість членів сім'ї) як суму батьків і дітей (`Parch`) та братів і сестер (`SibSp`), які пливли разом із пасажиром

- До змінних можна застосовувати дуже багато різних функцій

- У відповідних джерелах завжди можна знайти, як реалізувати ту чи ту ідею

## Комбінування різних операцій

- Майже завжди потрібно застосувати декілька операцій одночасно

- Результат кожної з них можна зберігати в окремій змінній

- Для підвищення читовности коду ці операції ліпше поєднувати за допомогою т.зв. **pipes** (підстановок):
```{r tidyverse6, indent = "    "}
passengers %>% mutate(FamSize = Parch + SibSp) %>%
    arrange(desc(FamSize))
```

- Ми створили нову змінну і відразу відсортували датафрейм за спаданням її значень

- Можна помітити, що великі родини мають тенденцію не виживати

## Відбір окремих стовпців (1)

- Інколи для продовження ефективної роботи з датафреймом буває корисно позбутися зайвих стовпців

- Це можна здійснити за допомогою функції `select()`

- Аргументами повинні стати назви стовпців, які потрібно залишити
```{r tidyverse7, indent = "    "}
passengers %>% mutate(FamSize = Parch + SibSp) %>%
    select(Survived, Sex, Age, FamSize)
```

## Відбір окремих стовпців (2)

- Якщо знати порядок розташування стовпців, можна використовувати `:` для вказання першого й останнього стовпця з певного переліку (напр., `ticket:embarked`)

- Якщо стовпців дуже багато, а потрібно викинути тільки деякі, то можна використати від'ємну індексацію
```{r tidyverse8, indent = "    "}
passengers %>% mutate(FamSize = Parch + SibSp) %>%
    select(-c(Parch, SibSp))
```


## Перейменування змінних

- Для того, щоб перейменувати деяку змінну, можна використати функцію `rename()`

- Аргументами повинні стати пари *нова назва*--*стара назва*
```{r tidyverse9, indent = "    "}
passengers %>% mutate(FamSize = Parch + SibSp) %>%
    rename(ID = PassengerId, Class = Pclass)
```

## Підрахунок підсумкових показників

- Дуже часто потрібно підрахувати деякі підсумкові статистики для наших даних

- До таких належать вибіркове середнє, медіана, середньоквадратичне відхилення та багато інших

- Для роботи з датафреймами потрібно використовувати функцію `summarize()`

- Аргументами повинні стати пари *назва результату*--*функція від змінних*

- У результаті дістаємо новий датафрейм із відповідними стовпцями та одним рядком
```{r tidyverse10, indent = "    "}
passengers %>% summarize(meanFare = mean(Fare), medianFare = median(Fare))
```

- Звісно, статистики можна рахувати і для деякої підмножини спостережень
```{r tidyverse11, indent = "    "}
passengers %>% filter(Sex == "male") %>% 
    summarize(meanFare = mean(Fare), medianFare = median(Fare))
```

## Підрахунок підсумкових показників за групами

- Дуже часто виникає потреба рахувати статистики для різних категорій одночасно

- Наприклад, нас можуть цікавити середнє та медіана вартости квитка для чоловіків і для жінок окремо

- Використовувати прийом із попереднього слайду нераціонально

- Тому спочатку дані **групують** за допомогою функції `group_by()`
```{r tidyverse12, indent = "    "}
passengers %>% group_by(Sex) %>% 
    summarize(meanFare = mean(Fare), medianFare = median(Fare))
```

- У результаті маємо датафрейм, де кожний рядок відповідає окремій категорії

- Особливо корисною є функція `n()`, яка рахує число спостережень у групі
```{r tidyverse13, indent = "    "}
passengers %>% group_by(Sex) %>% 
    summarize(meanFare = mean(Fare), propSurv = sum(Survived) / n())
```

- Ми порахували середню вартість квитка і **частку** вцілілих пасажирів

- Як можна бачити, результати такого **примітивного** аналізу свідчать, що серед жінок уцілілих значно більше, а квитки в них у середньому були дорожчі
