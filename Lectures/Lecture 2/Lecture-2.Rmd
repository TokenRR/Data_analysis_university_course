---
title: "Лекція 2. Візуалізація та розвідковий аналіз даних в R"
author: "Данило Тавров"
date: "15.02.2023"
output:
  beamer_presentation:
    theme: Madrid
    toc: false
    colortheme: "seahorse"
    fonttheme: serif
    latex_engine: xelatex
    includes:
      in_header: "../latex/preamble.tex"
    highlight: tango
    incremental: true
    # df_print: kable
    # pandoc_args: ["--extract-media", "."]
    dev: cairo_pdf
fontsize: 9pt
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(GGally)
```

## Ідея сьогоднішньої лекції

- Ми розглянемо деякі принципи EDA та його основні складові

- Корисними матеріалами є:
    + Книжка [*Exploratory Data Analysis with R*](https://bookdown.org/rdpeng/exdata/) (PDF версія доступна на диску в каталозі з лекцією), особливо розділи 1, 4, 5, 6, 16
    + Відповідний [розділ](https://r4ds.had.co.nz/exploratory-data-analysis.html) у книжці *R for Data Science*
    + Книжка [*Exploratory Data Analysis Using R*](https://www.amazon.com/Exploratory-Analysis-Chapman-Knowledge-Discovery/dp/149873023X) (PDF версія доступна на диску в каталозі з лекцією), особливо розділи 3 і 9.6--9.7
    + [Курс з EDA](https://bayesball.github.io/EDA) авторства Джима Алберта (Jim Albert)
    + Цей курс базується на класичній ^[Хоча й доволі застарілій!] книжці Джона Т'юкі (John Tukey) *Exploratory Data Analysis*, який є основоположником багатьох принципів EDA
    
- Проведенню EDA буде присвячено Лабораторну роботу №1

- Очікується, що студенти проведуть додатковий аналіз джерел та застосують методи за межами лекційного матеріалу





# Загальні міркування про EDA

## Що таке EDA (1)

- Як такого визначення EDA не існує

- Можна провести корисну паралель зі зйомками кіно
    + Як правило, знімаючи кіно, знімають багато матеріалу, і не весь буде використано в остаточному продакшені
    + Понад те, сцени знімають не в тому порядку, у якому вони з'являться в остаточній версії
    + У монтажній кімнаті режисер та монтажер можуть експериментувати з різними варіантами сцен та відбирати найліпші версії
    + Слабкі сцени можуть викинути, а цікаві --- розширити та взагалі перезняти
    + Такий монтаж проводять нашвидкуруч, щоб відразу зрозуміти, як рухатися далі
    + Тонкощі на кшталт світла чи графіки на цьому етапі не розглядають
    
- У цьому сенсі EDA подібний до роботи в монтажній кімнаті

- Він передує повноцінному аналізу з метою:
    + Перевірки наявних даних на помилки чи інші проблеми, які варто усунути (пропущені дані тощо)
    + Виявлення додаткових потреб у даних, які потрібно зібрати
    + Виявлення залежностей між змінними, які становлять цікавість або є неочікуваними
    + Пошуку свідчень на підтримку деяких гіпотез

- Отже EDA дає зрозуміти досліднику, на що можна звернути особливу увагу, а які ідеї не варто розвивати

## Що таке EDA (2)

- EDA можна також порівняти з роботою детектива
    + Детектив шукає злочинця на підставі наявних доказів
    + Виконуючи EDA, ми намагаємося з'ясувати якісь закономірності на підставі наявних даних
    + Ми прагнемо підсумувати інформацію про дані та описати у відносно простий спосіб, про що вони нам кажуть

- EDA варто відрізняти від аналізу даних, спрямованого на підтвердження (чи спростування) гіпотез (confirmatory data analysis)
    + Ми цим будемо займатися майже весь інший час нашого курсу

- Аналіз гіпотез потребує застосування відповідних статистичних методів

- Його можна порівняти з судовим процесом

- Але якщо детектив не збере свідчень і не сформулює обвинувачення, суду взагалі не буде з чим працювати 

## Що таке EDA (3)

- EDA --- це ітеративний процес, що передбачає:
    + Формулювання питання
    + Відповідь на нього за допомогою візуалізації, перетворення чи моделювання даних
    + Уточнення питання на основі здобутої інформації

- Це доволі творчий процес без чітко встановлених правил

- На початкових етапах потрібно розглянути будь-які ідеї, що спадають на думку

- Найліпші ідеї можуть бути предметом дальших досліджень у рамках інференційного, прогнозного або причиново-наслідокового аналізу даних

## Що таке EDA (4)

- Набори даних, із якими доводиться працювати, дуже часто мають великий обсяг

- Їх можуть збирати люди чи організації, до яких у нас немає доступу і діяльність яких ми не можемо контролювати

- Навіть якщо дані збирає сам дослідник, він часто використовує спеціальні засоби на кшталт веб-скрейперів (web scrapers)

- Тому першим кроком в аналізі даних є ознайомлення з їхньою структурою, наявністю помилок, пропущених значень тощо

- Після цього в рамках EDA нас цікавлять відповіді на два широкі класи питань:
    + Якого роду варіація має місце в наших змінних? (Який розподіл?)
    + Якого роду **ко**варіація має місце **між** нашими змінними?

## Чотири принципи EDA

- Розгляньмо чотири принципи EDA^[Velleman P. F.,   Hoaglin D. C. Data analysis. In: Hoaglin D. C., Moore D. S. (eds.), Perspectives on Contemporary Statistics, Mathematical Association of America (1991)], також відомі як *чотири R*

- Revelation (відкриття): мається на увазі візуалізація даних як ключова складова EDA

- Residuals (залишки): мається на увазі важливість аналізу різниць між наявними даними та результатами застосування формальної «модели»
    + У контексті EDA моделі дуже простенькі (наприклад, накладена зверху щільність нормального розподілу), їх не варто плутати з тими моделями, які ми вивчатимемо далі в нашому курсі

- Reexpression (трансформація): часто для того, щоб побачити щось корисне в даних, їх спочатку потрібно трансформувати (взяти логаритм, піднести до ступеня тощо)

- Resistance (стійкість): аналіз даних не повинен залежати від наявности викидів (дуже великих чи дуже малих значень, які вибиваються з загального розподілу)


## Основні кроки в рамках EDA

- Спочатку потрібно розібратися з основними характеристиками набору даних:
     + Скільки в ньому спостережень і змінних?
     + Які назви мають змінні, наскільки вони адекватні, чи варто їх перейменувати?
     + Якого типу змінні, наскільки вони відповідають суті, чи варто їх перекодувати?
     + Скільки унікальних значень має кожна змінна? Які значення повторюються найчастіше?
     + Чи є пропущені дані? Наскільки багато? Чому?

- Для кожної змінної, яка становить інтерес, доцільно провести дескриптивний аналіз

- Для важливих змінних потрібно виконати візуалізацію як особливостей розподілу кожної змінної окремо, так і взаємозв'язку між різними змінними

- Якщо в наборі даних наявні викиди чи інші аномалії, із ними потрібно розібратися



# Дескриптивний аналіз даних

## Огляд структури набору даних (1)

- Для початку роботи з набором даних доцільно ознайомитися з його структурою

- Використаймо знову [дані про пасажирів  «Титаніку»](https://www.kaggle.com/competitions/titanic/data)

- Після скачування відповідного файлу формату CSV та розміщення у відповідному каталозі, ми його зчитуємо та проглядаємо структуру
```{r load, indent = "    ", message = FALSE}
passengers <- read_csv("data/titanic.csv")
str(passengers, give.attr = FALSE)
```

## Огляд структури набору даних (2)

- Можемо бачити, що в ньому 891 спостереження і 12 змінних

- Також бачимо типи всіх змінних
    + Змінні `Sex` та `Embarked` мають символьний формат, хоча перелік їхніх значень свідчить, що це по суті категорійні змінні
```{r str_sex, indent = "        "}
table(passengers$Sex)
table(passengers$Embarked)
```
    + Те саме можна сказати про «числові» змінні `Survived` і `Pclass`
```{r str_survived, indent = "        "}
table(passengers$Survived)
table(passengers$Pclass)
```
    + Перетворімо ці змінні у фактори (а `Pclass` додатково --- у впорядкований фактор)
```{r str_to_factors, indent = "        "}
passengers <- passengers %>% mutate(Sex = as.factor(Sex), Embarked = as.factor(Embarked),
    Survived = as.factor(Survived), Pclass = as.ordered(Pclass))
```

- Усі назви приблизно мають сенс (і принаймні не містять недозволених символів)
    + За потреби можна перейменувати деякі назви типу `SibSp` чи `Parch`

## Огляд структури набору даних (3)

- Також у наборі даних корисно подивитися, скільки для кожної змінної є пропущених значень
```{r passengers_na, indent = "    "}
passengers %>% summarise(across(everything(), ~ sum(is.na(.)))) %>%
  select(where(~ all(.) > 0))
```

- Також може бути корисно проглянути *частку* пропущених значень
```{r passengers_na2, indent = "    ", warning = FALSE, message = FALSE}
passengers %>% summarise(across(everything(), ~ mean(is.na(.)))) %>%
  select(where(~ all(.) > 0))
``` 

- Як можна бачити, тільки 2 значення пропущено для змінної `Embarked`, але понад 77% даних пропущено в стовпчику `Cabin`

- Також майже 20% пропущено значень віку пасажирів (`Age`)

- Тому якщо рядки з пропущеними значеннями `Embarked` можна просто не враховувати (їх дуже мало і вони ні на що не впливають), то змінну `Cabin`, певно, навряд чи можна з користю застосувати

- Що стосується змінної `Age`, то потрібний детальніший аналіз

## Огляд структури набору даних (4)

- Варто пам'ятати, що пропущені дані можуть кодувати у специфічний спосіб

- Наприклад, змінна може бути цілочисельна і не мати  пропусків

- Але вона може мати значення `-1`, `999` тощо, які варто сконвертувати в пропущені

- Перевірмо це, наприклад, для наших даних
```{r passengers_age_missing, indent = "    "}
table(passengers$Age)
```

- Ми бачимо, що вік усюди лежить в адекватних межах, але вік деяких пасажирів указано з точністю до місяця

- Округлювати їх не обов'язково, але варто врахувати, що не всі є цілочисельними

- Пропущені дані можуть також ховатися у даних символьного типу
    + Часто порожні рядки або рядки з суцільних пробілів насправді позначають пропущені дані

- Корисний приклад проведення аналізу структури даних можна почитати у відповідному [розділі книжки *Exploratory Data Analysis*](https://bookdown.org/rdpeng/exdata/exploratory-data-analysis-checklist.html)

## Підсумкові характеристики числової змінної (1)

- Найпростіше, що можна дізнатися про розподіл (числової) змінної --- це її підсумкові характеристики (summary)

- Це дасть змогу, у першу чергу, зрозуміти **типові** значення та загальні риси розподілу

- Ключовими характеристиками числової змінної є її «середнє» значення так «розкид» значень навколо «середнього»

- Із теорії ймовірностей ми знаємо, що відповідні характеристики випадкової величини $X$ мають назву **сподівання** (expectation) $\EE{X}$ та **дисперсії** (variance) $\Var{X}$ 
    + На практиці замість дисперсії ліпше використовувати **середньоквадратичне відхилення** (standard deviation) $\sigma_X = \sqrt{\Var{X}}$
    + Воно має ті ж одиниці виміру, що й сама величина 

## Підсумкові характеристики числової змінної (2)

- Нехай маємо вибірку $X_1, \ldots, X_n$, $X_i \sim \PPsym_X$, де $\PPsym_X$ --- розподіл $X$

- Тоді оцінити сподівання й дисперсію можна за допомогою **середнього вибіркового** (sample mean) 
\[
\overline{X} = \frac{1}{n}\sum_{i=1}^n X_i
\]
та **вибіркової дисперсії** (sample variance)
\[
S_{X} = \frac{1}{n - 1}\sum_{i=1}^n \left(X_i - \overline{X}\right)^2
\]

- Проте ці вибіркові статистики є чутливі до викидів

- Тому часто основними підсумковими значеннями про величину вважають такі **п'ять**:
    + Мінімум
    + Перший квартиль
    + Медіана
    + Третій квартиль
    + Максимум

## Підсумкові характеристики числової змінної (3)

\begin{defn}
	\label{defn:median}
Число $M$ називають \textbf{медіаною} (median) випадкової величини $X$ із розподілом $\mathbb{P}_X$, якщо
\[
\mathbb{P}_X(X \leq M) \geq \frac{1}{2}\;, \qquad \mathbb{P}_X(X \geq M) \geq \frac{1}{2}
\]
\end{defn}


- Визначення \ref{defn:median} медіани в теорії ймовірностей трішки складніше, ніж потрібно на практиці

- На практиці медіану вибірки розміром $n$ визначають так:

- Якщо $n$ парне, $M$ дорівнює середньому елементу у відсортованій вибірці

- Якщо $n$ непарне, $M$ дорівнює середньоаритметичному двох середніх елементів

## Підсумкові характеристики числової змінної (4)

\begin{defn}
	\label{defn:quartile}
	
	\begin{itemize}[<+->]
	  \item Число $x_p$ називають $p$\textbf{-им квантилем}  ($p$th quantile) випадкової величини $X$ із розподілом $\mathbb{P}_X$, якщо
\[
\mathbb{P}_X({X \leq x_p}) \geq p\;, \qquad \mathbb{P}_X(X \geq x_p) \geq 1 - p
\]
    \item $x_{0.25}$ називають \textbf{першим квартилем} (first quartile)
    \item $x_{0.5}$ --- це і є медіана
    \item $x_{0.75}$ називають \textbf{третім квартилем} (third quartile)
  \end{itemize}
\end{defn}

- На практиці існують різні підходи до підрахунку квартилів:
    + Функція `summary` рахує їх згідно з вищенаведеним визначенням
    + Функція `stats::fivenum` рахує їх як медіани відповідних інтервалів

- Відстань між першим і третім квартилями називають **міжквартильним розмахом** (interquartile range, IQR)
    + На відміну від середньоквадратичного відхилення (standard deviation), IQR стійкий до викидів
    + Інтерпретація проста: в IQR потрапляють (приблизно) середніх 50% даних


## Підсумкові характеристики числової змінної (5)

- Наприклад, можемо обчислити всі середні та середньоквадратичні відхилення для всіх (числових) змінних
```{r passenger_means, indent = "    "}
bind_rows(
  mean = passengers %>% summarize(across(where(is.numeric), mean, na.rm = TRUE)),
  sd = passengers %>% summarize(across(where(is.numeric), sd, na.rm = TRUE)),
  .id = "statistic"
)
```

- Ми вказали `na.rm = TRUE`, інакше в стовпчику `Age` були б `NA` замість результату

- Аналогічно можна порахувати будь-які інші статистики

## Підсумкові характеристики числової змінної (6)

- Також можна використати функцію `summary`
```{r passenger_summary, indent = "    "}
summary(passengers %>% select(where(is.numeric)))
```

- На перший погляд нічого особливого у вічі не кидається

- Такого роду інформацію корисно візуалізувати, до чого ми повернемося пізніше

## Підсумкові характеристики числової змінної (7)

- Класичним прикладом^[Anscombe F. J. Graphs in statistical analysis, The American Statistician 27, 17--21 (1973)], що ілюструє обмеженість тільки дескриптивних статистик, є датафрейм `anscombe` із пакета `datasets`
```{r anscombe_summary, indent = "    "}
bind_rows(
  mean = anscombe %>% summarize(across(everything(), mean, na.rm = TRUE)),
  sd = anscombe %>% summarize(across(everything(), sd, na.rm = TRUE)),
  median = anscombe %>% summarize(across(everything(), median, na.rm = TRUE)),
  .id = "statistic"
)
```

- Як можна помітити, середні та середньоквадратичні відхилення (але не медіани) дуже подібні як для змінних `x`, так і для змінних `y`

## Підсумкові характеристики числової змінної (8)

- Проте графічні зображення свідчать про посутні відмінності між цими наборами даних
```{r anscombe_plot, indent = "    ", out.width = "80%", fig.align = "center", warning = FALSE}
par(mfrow = c(2, 2))
plot(anscombe$x1, anscombe$y1)
plot(anscombe$x2, anscombe$y2)
plot(anscombe$x3, anscombe$y3)
plot(anscombe$x4, anscombe$y4)
```


## Викиди в числових змінних (1)

- Кажучи неформально, **викид** (outlier) --- це таке значення змінної, яке несумісне з розподілом інших

- Викиди важко визначити формально, але дуже добре видно на графіках

```{r passengers_outliers, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, fig.show = "hide"}
plot(passengers$Fare)
```

\visible<+->{
```{r, echo = FALSE, out.width = '50%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('passengers_outliers', 'pdf'))
```
}

- У вічі кидаються три викиди, пов'язані з дуже високими цінами на квитки

- Наявність таких викидів спотворює статистичні характеристики вибірки

- Раніше ми порахували, що середнє змінної `Age` дорівнює 29.70, а медіана --- 28

- У той же час середнє змінної `Fare` дорівнює 32.20, а медіана --- 14.45

- Тобто наявність великих викидів сильно завищила середнє значення

- Використання даних у статистичних моделях вестиме до хибних висновків

## Викиди в числових змінних (2)

- Існують різні методи, як можна визначити викиди в деякій вибірці $\mathbf{x} = (x_1, \ldots, x_n)$, проте жоден не є ідеальним

- Якщо вибірка походить із нормального розподілу (тобто вибірка є реалізацією $\mathbf{X} = (X_1, \ldots, X_n)$, $X_i \simiid N(\mu, \sigma^2)$), то можна застосувати **правило трьох сигм** (the three sigma rule)
     + Тобто вважати викидом будь-яке значення $x \notin \left[\overline{x} - 3\sqrt{S_x}; \overline{x} + 3\sqrt{S_x}\right]$
     + Звісно, такий підхід погано працюватиме, якщо дані містять викиди, адже сподівання буде спотворене!

- Стійкіший метод полягає в тому, щоб вважати за викид будь-яке спостереження $x \notin [M - 1.5\cdot \text{IQR}; M + 1.5\cdot \text{IQR}]$

- Іще ліпший підхід полягає в застосуванні так званого **фільтру Гампеля** (Hampel filter)^[Швейцарський математик Франк Гампель (Frank Hampel,  1941--2018)]
    + Викидом є будь-яке спостереження $x \notin [M - 3\cdot \text{MAD}; M + 3\cdot \text{MAD}]$
    + Тут MAD --- **медіанне абсолютне відхилення** (median absolute deviation):
\[
\text{MAD} = \dfrac{1}{\Phi^{-1}(0.75)} \cdot \text{median}(\mathbf{x} - M) \approx 1.4826 \cdot \text{median}(\mathbf{x} - M)
\]
    + (Відповідний коефіцієнт потрібний для того, щоб $\mathbb{E}(MAD) = \sigma$ для нормальної вибірки)

## Викиди в числових змінних (3)

- Застосування до наших даних дає
```{r hampel, indent = "    "}
passengers %>% filter(Fare < median(Fare) - 3*mad(Fare) | Fare > median(Fare) + 3*mad(Fare)) %>%
  arrange(desc(Fare))
```

- Як можна бачити, ця процедура доволі жорстка, адже викидів виявлено доволі багато

## Викиди в числових змінних (4)

- Можна сформулювати такі загальні рекомендації

- Застосувати різні методи виявлення викидів і порівняти відповідні результати

- Застосувати логічне мислення та знання предметної области, щоб визначити, чи є формально виявлені викиди такими насправді

- Проаналізувати відповідні графіки на предмет виявлення справді великих викидів, на які потрібно звернути увагу

## Викиди в числових змінних (5)

- Корисний (візуальний) інструментарій для виявлення викидів полягає в побудові так званого **Q-Q-графіка** (Q-Q plot, quantile-quantile plot)

- Якщо просто, ідея полягає в тому, щоб на одній осі розмістити квантилі одного розподілу, а на іншій --- другого

- Дуже часто на осі абсцис розміщують теоретичні квантилі (стандартного) нормального розподілу

- Тоді якщо на графіку ми бачимо (приблизно) пряму лінію, ми робимо висновок, що дані мають «приблизно нормальний» розподіл

- Також ці графіки дають змогу побачити викиди

## Викиди в числових змінних (6)

- Побудуймо відповідний графік для змінної `Fare`
```{r passengers_qqplot, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, cache = TRUE, fig.show = "hide"}
qqnorm(passengers$Fare)
```

\visible<+->{
```{r, echo = FALSE, out.width = '50%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('passengers_qqplot', 'pdf'))
```
}

- По-перше, ми бачимо, що розподіл не є нормальний (про це --- далі)

- Але також ми чітко бачимо три великі викиди і декілька дивних значень, близьких до нуля

## Викиди в числових змінних (6)

- Викиди в загальному випадку можуть бути як результатом помилок під час уведення даних, так і особливостями самої вибірки

- Подивімося, наприклад, на пасажирів із нульовою ціною квитка
```{r passengers_zero_fare, indent = "    "}
passengers %>% filter(Fare == 0)
```

- За цими даними неможливо чітко стверджувати, що нульова ціна є помилковою, адже інші значення цілком адекватні

- Відповідне питання потребує детального аналізу, у тому числі зовнішніх джерел
    + Можливо, справді були пасажири, які пройшли безкоштовно?

- В інших випадках може бути очевидно, що дані явно неправильні
    + Не там стоїть кома, зайвий нуль і тому подібне



## Інші проблеми з даними

- Поширеною є ситуація, коли змінна є нібито числовою і дійсною, але окремі значення зустрічаються **надто** часто
    + Це може свідчити про використання якихось кодів на позначення пропущених даних
    + Також це може бути пов'язано з особливостями збору даних, коли замість невідомого значення вказують якесь значення за замовчуванням

- Наприклад, розгляньмо датафрейм `Boston` із пакета `MASS` (інформація про деякі будинки в передмістях Бостона^[Harrison D., Rubinfeld D. L. Hedonic prices and the demand for clean air. Journal of Environmental Economics and Management (5), 81--102 (1978)])
```{r MASS, indent = "    "}
table(MASS::Boston$tax)
```

- Як можна бачити, змінна `tax` (податок, у доларах, на кожні 10 000 доларів повної вартости будинку) набуває різних значень

- Але значення `666` вона набуває особливо часто
    + Це може бути просто збіг обставин
    + Або це може свідчити про особливості кодування даних тощо


## Таблиці спряжености (1)

- Якщо маємо справу з категорійними змінними, то корисним способом їх відображення є **таблиця спряжености** (contingency table)

- У цій таблиці рядки та стовпці відповідають категоріям двох змінних

- В R можна підрахувати таблицю спряжености за допомогою функції `xtab`
```{r xtabs, indent = "    "}
cont_tab <- xtabs(~ Survived + Sex, data = passengers)
cont_tab
```

- Першим аргументом функції є так звана **формула**
    + Ми їх часто зустрічатимемо в нашому курсі в різних контекстах

- Тут справа від `~` стоять змінні, які потрібно зобразити в таблиці

- Зліва може стояти змінна, у якій містяться значення, які потрібно сумувати за категоріями
    + За замовчуванням рахують просто загальне число спостережень
    
## Таблиці спряжености (2)

- Дуже корисним є додавати в таблицю спряжености **маржинальні розподіли** (marginal distributions) 
```{r xtabs_margins, indent = "    "}
addmargins(cont_tab)
```

- Можна побудувати маржинальні розподіли окремо за рядками (`margin = 1`) та стовпцями (`margin = 2`)
```{r xtabs_margins2, indent = "    "}
margin.table(cont_tab, margin = 1)
margin.table(cont_tab, margin = 2)
```

## Таблиці спряжености (3)

- Можна перетворити таблицю спряжености в таблицю емпіричного спільного розподілу:
```{r prop.table, indent = "    "}
joint_dist <- prop.table(cont_tab)
joint_dist
sum(joint_dist)
```

- А вказавши аргумент `margin`, можна збудувати ще й умовні розподіли
```{r prop.table_margin, indent = "    "}
cond_dist_given_row <- prop.table(cont_tab, margin = 1)
cond_dist_given_row
```

- Наприклад, `r round(cond_dist_given_row[2, 1], 4) * 100`% жінок вижило **серед усіх тих, хто вижив**   

## Таблиці спряжености (4)

- Також можна будувати таблиці спряжености з декількома змінними
```{r xtabs_mult, indent = "    "}
ftable(xtabs(~ Survived + Sex + Pclass, data = passengers))
```

- Функція `ftable` сплющує (flattens) багатовимірну таблицю у приємний формат

# Основи використання `ggplot2`

## Вступні зауваги

- Як і в попередній лекції, метою не є вичерпний огляд можливостей пакету `ggplot2` для візуалізації даних

- Ми розглянемо найважливіші види графіків та засоби їх побудови

- Корисну інформацію можна дістати з книжки [*`ggplot2`: Elegant Graphics for Data Analysis*](https://ggplot2-book.org/index.html)
    + PDF версія доступна на диску (у каталозі з літературою), але видання різні, тому й структура різна
    + Особливу увагу варто звернути на такі розділи: 1, 2, 3--4 (по діагоналі), 8, 11, 15, 18

- **Прекрасним джерелом** є [галерея графіків](https://r-graph-gallery.com/) із відповідними поясненнями та кодом, як їх будувати

- Додаткову інформацію про можливості `ggplot2` можна дізнатися [на офіційному сайті](https://ggplot2.tidyverse.org/reference/)

- Інші корисні джерела:
    + [R Graphics Cookbook](https://r-graphics.org/): набір конкретних прикладів
    + Відповідний розділ із книжки [Modern Dive](https://moderndive.com/2-viz.html)
    + Українською можна подивитися відео від [І. Мірошниченка](https://www.youtube.com/watch?v=QpUgqvp7MTs&list=PLWL2vVyKljMPHHIOQ-ArCwIoUfvVrvH_a&index=14&t=6605s)
    + Корисною є шпаргалка (cheat sheet) за [посиланням](https://posit.co/resources/cheatsheets/), її також викладено на диск

- Також завжди можна звернутися до сайтів [Stack Overflow](https://stackoverflow.com/) та [Stack Exchange](https://stackexchange.com/)

## Що таке `ggplot2`

- Пакет `ggplot2` є одним із базових пакетів `tidyverse`

- Літери `gg` розшифровуються як *grammar of graphics* ^[Wilkinson L. The Grammar of Graphics, Springer-Verlag, New York (2005)]

- Побудова графіка здійснюється пошарово:
    + Спочатку вказуються дані в охайному форматі
    + Потім додаються параметри «естетики» (aesthetics) графіка (що стоїть на осях координат, колір, розмір, форма тощо)
    + Потім зазначається «геометрія» графіка (geometry), тобто якими геометричними фігурами потрібно відобразити дані (точки, лінії, стовпчики тощо)
    + Поверх цього уточнюється координатна система, підписи осей, легенда тощо

## Дуже коротко про граматику графіків

- Розгляньмо базові поняття, які будемо використовувати

- Графіки будуються на основі **даних** та **відображення** (mapping), яке показує, як змінні з датафрейму відображаються на атрибути естетики

- Існує 5 основних компонентів відображення:
    + **layer**: набір геометричних елементів та статистичних перетворень
        * **geom**: точки, лінії, багатокутники тощо
        * **stat**: побудова гістограми, оцінювання параметрів прямої за методом найменших квадратів тощо
    + **scale**: ставить у відповідність дані до їхнього візуального вигляду (колір, форма точки, товщина лінії тощо), також відповідає за легенду та осі
    + **coord**: описує, як дані розташовані на графіку (включає в себе осі та координатні сітки). Як правило, ми використовуємо прямокутову систему за замовчуванням
    + **theme**: управляє розміром шрифту, фоновим кольором тощо
    + **facet**: уточнює, як на одному графіку зобразити декілька панелей

## Перший графік

- Використовуючи датафрейм про пасажирів «Титаніку», можемо побудувати простий графік:
```{r ggplot_empty, indent = "    ", out.width = "50%", fig.align = "center"}
ggplot(passengers, aes(x = Age, y = Fare))
```

- Використано такі аргументи функції `ggplot`:
    + Перший аргумент --- завжди датафрейм
    + Другий аргумент --- параметри естетики (у нашому випадку: яка змінна стоїть на якій координатній осі)

## Додавання геометрії в графік

- Але побудований графік нічого не показує!

- Це тому, що ми тільки вказали естетичні параметри графіка

- Додатково потрібно задати геометрію графіка: усі відповідні функції починаються з `geom_`
    + `geom_point` використовують для побудови **діаграм розсіювання** (scatter plots)
    + `geom_line` використовують для побудови кривих (дуже корисно для зображення часових рядів)
    + `geom_bar` використовують для побудови **стовпчастих діаграм** (bar plots)
    + `geom_boxplot` використовують для побудови **коробкових графіків** (box plots)
    + `geom_histogram` використовують для побудови гістограм
    + ...і багато інших

## Scatter plots

- Збудуймо перший scatter plot
```{r ggplot_scatter, indent = "    ", out.width = "50%", fig.align = "center"}
ggplot(passengers, aes(x = Age, y = Fare)) +
    geom_point()
```

- Кожного пасажира зображено окремою точкою

- Функція `geom_point` у даному випадку не має власних аргументів

- Це тому, що вона **наслідує** як датафрейм, так і атрибути естетики з виклику функції `ggplot`

- Що цікавого видно на графіку?

## Заголовок графіка та підписи осей

- Для того, щоб графік мав привабливіший вигляд, можна уточнити параметри його відображення

- Для початку можна додати заголовок графіка та підписати осі координат

```{r ggplot_labels, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Age, y = Fare)) +
    geom_point() +
    labs(x = "Вік пасажира", y = "Ціна за квиток, фунти",
         title = "Квитки пасажирів Титаніку")
```

\visible<+->{
```{r, echo = FALSE, out.width = '50%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_labels', 'pdf'))
```
}

- Очевидно, розмір шрифту для осей  недостатній

## Збільшення розміру шрифту

- Для  збільшення розміру шрифту потрібно використати функцію `theme`
```{r ggplot_size, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(passengers, aes(x = Age, y = Fare)) +
    geom_point() +
    labs(x = "Вік пасажира", y = "Ціна за квиток, фунти",
         title = "Квитки пасажирів Титаніку") +
    theme(text = element_text(size = 30))
```

- Можна змінювати шрифти:
    + Окремо для міток на осях (замість `text` указати `axis.text`)
    + Окремо для назв осей (замість `text` указати `axis.title`)
    + Окремо для заголовку графіка (замість `text` указати `plot.title`)
    + Окремо для елементів легенди (замість `text` указати `legend.text`)
    + Окремо для заголовку легенди (замість `text` указати `legend.title`)

- Можна змінювати не тільки розмір (`size`), а й колір (`color`), сам шрифт (`family`), задавати жирність або курсив (`face`) тощо

## Додавання кольору (1)

- Часто корисним є зображення спостережень із різних класів різними кольорами

- У нашому випадку доцільним є використання різних кольорів для статей

- Для колоризації потрібно вказати додатковий параметр естетики

```{r ggplot_scatter_color, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Age, y = Fare, color = Sex)) +
    geom_point() +
    labs(x = "Вік пасажира", y = "Ціна за квиток, фунти",
         title = "Квитки пасажирів Титаніку", color = "Стать") +
    theme(plot.title = element_text(size = 30),
          axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '40%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_scatter_color', 'pdf'))
```
}

- Можна помітити, що серед власників найдешевших квитків чоловіків більше

- Зверніть увагу, що ми вказали назву «Стать» для легенди

## Додавання кольору (2)

- Назви ключів легенди нас не задовольняють: потрібні україномовні відповідники
```{r ggplot_scatter_color_2, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(passengers, aes(x = Age, y = Fare, color = Sex)) +
    geom_point() +
    labs(x = "Вік пасажира", y = "Ціна за квиток, фунти",
         title = "Квитки пасажирів Титаніку", color = "Стать") +
    scale_color_discrete(labels = c("Жінка", "Чоловік")) +
    theme(plot.title = element_text(size = 30),
          axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

- Ми використали функцію, яка починається з префікса `scale_`

- Як і інші аналогічні, вона відображає дані в простір естетики (тут, колір)

- `scale_color_discrete` є за замовчуванням для категорійних змінних

- Ми тільки уточнили перелік назв ключів за допомогою аргументу `labels`

## Додавання кольору (3)

- Якщо ми хочемо власноруч задати кольори, це можна зробити так:

```{r ggplot_scatter_color_manual, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(passengers, aes(x = Age, y = Fare, color = Sex)) +
    geom_point() +
    labs(x = "Вік пасажира", y = "Ціна за квиток, фунти",
         title = "Квитки пасажирів Титаніку", color = "Стать") +
    scale_color_manual(values = c("red", "blue"),
                       labels = c("Жінка", "Чоловік")) +
    theme(plot.title = element_text(size = 30),
          axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

- Вектор значень кольорів впорядковано за значеннями факторної змінної
```{r factor order, indent = "    "}
levels(passengers$Sex)
```

## Модифікація інших атрибутів естетики (1)

- Можна уточнити форму зображуваних точок

```{r ggplot_scatter_shape, indent = "    ", out.width = "60%", fig.align = "center", warning = FALSE}
ggplot(passengers, aes(x = Age, y = Fare, shape = Sex)) +
    geom_point() +
    labs(x = "Вік пасажира", y = "Ціна за квиток, фунти", shape = "Стать") +
    scale_shape_discrete(labels = c("Жінка", "Чоловік")) +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

- Ми використали `scale_shape_discrete`, який іде за замовчуванням, але уточнили ключі легенди

## Модифікація інших атрибутів естетики (2)

- Нарешті, можна керувати розміром точок

- Наприклад, поставити у відповідність розмір точки до числа членів родини

```{r ggplot_scatter_color_size, indent = "    ", out.width = "60%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Age, y = Fare, color = Sex, size = Parch + SibSp)) +
    geom_point() +
    labs(x = "Вік пасажира", y = "Ціна за квиток, фунти",
         color = "Стать", size = "Розмір родини") +
    scale_color_discrete(labels = c("Жінка", "Чоловік")) +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '60%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_scatter_color_size', 'pdf'))
```
}

## Задавання атрибутів естетики для всього графіка

- Інколи є потреба задати колір, розмір тощо єдиний для всього графіка

- Тоді відповідні параметри можна **винести за межі** відповідної естетики, в окремий шар

```{r ggplot_scatter_color_blue, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Age, y = Fare)) +
    geom_point(color = "blue") +
    labs(x = "Вік пасажира", y = "Ціна за квиток, фунти") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '50%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_scatter_color_blue', 'pdf'))
```
}

## Особливості використання атрибутів естетики

- Різні атрибути естетики варто використовувати по-різному, залежно від типу зображуваних змінних

- Використання різних кольорів чи форм доцільно для категорійних змінних, де перелік можливих варіантів обмежений

- Для неперервних змінних кориснішим є використання розміру, оскільки це також неперервна величина

- Потрібно зважати на загальну інтерпретовність графіка

- Якщо графік стає перевантаженим, ліпше розбити його на окремі панелі


## Фацетовані графіки (1)

- Наприклад, можна створити два окремі графіки --- для чоловіків і для жінок

- Точніше, це будуть **панелі** одного графіка, причому координатні осі будуть однакові

- Такі графіки називають **фацетованими** (faceted)

```{r ggplot_scatter_facet, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Age, y = Fare)) +
    geom_point() +
    labs(x = "Вік пасажира", y = "Ціна за квиток, фунти") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          strip.text = element_text(size = 20))  +
    facet_wrap(~Sex, labeller = as_labeller(c("female" = "Жінка", "male" = "Чоловік")))
```

\visible<+->{
```{r, echo = FALSE, out.width = '40%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_scatter_facet', 'pdf'))
```
}

- Аргументом `facet_wrap` є формула

- Також ми додали додатковий аргумент для україномовних заголовків

## Фацетовані графіки (2)

- Також можна створити фацетований графік, на якому різні панелі відповідатимуть статусу вцілілости пасажирів
```{r ggplot_scatter_facet_survived, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE}
ggplot(passengers, aes(x = Age, y = Fare, color = Sex)) +
    geom_point() +
    labs(x = "Вік пасажира", y = "Ціна за квиток, фунти", color = "Стать") +
    scale_color_manual(values = c("red", "blue"),
                       labels = c("Жінка", "Чоловік")) +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          strip.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))  +
    facet_wrap(~Survived, labeller = as_labeller(c("0" = "Не вцілів", "1" = "Вцілів")))
```

- Стає очевидним, що серед уцілілих пасажирів переважають жінки

## Модифікація загального вигляду графіка (1)

- Ми використовували стандартну theme із `ggplot2` (`theme_grey`)

- Єдине, що ми дозволяли собі міняти --- це розміри шрифтів

- Окрім шрифтів, міняти можна колір фону, параметри сітки і багато іншого

- Щоб не міняти кожний елемент окремо, існує низка готових themes

- Наприклад, класична тема
```{r ggplot_histogram_theme_classic, indent = "    ", out.width = "30%", fig.align = "center", warning = FALSE, message = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Age)) +
    geom_histogram() +
    labs(x = "Вік", y = "Кількість") +
    theme_classic() +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '50%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_histogram_theme_classic', 'pdf'))
```
}

## Модифікація загального вигляду графіка (2)

- Або темна
```{r ggplot_histogram_theme_classic2, indent = "    ", out.width = "30%", fig.align = "center", warning = FALSE, message = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Age)) +
    geom_histogram() +
    labs(x = "Вік", y = "Кількість") +
    theme_dark() +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '50%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_histogram_theme_classic2', 'pdf'))
```
}

- Перелік інших цікавих тем (у т.ч. з інших пакетів) можна знайти [тут](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/)

# Візуалізація даних у рамках EDA

## Box plots (1)

- Візуально п'ять основних підсумкових статистик про вибірку можна зобразити за допомогою box plots

- Можемо зобразити вікові розподіли пасажирів «Титаніка» за класом квитка

```{r ggplot_boxplot_3, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Pclass, y = Age)) +
    geom_boxplot() +
    labs(x = "Клас квитка", y = "Вік пасажира") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '40%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_boxplot_3', 'pdf'))
```
}

- Box plot показує п'ять основних дескриптивних статистик:
    + Мінімум --- нижня точка нижнього вуса
    + Перший квартиль --- нижня границя скриньки
    + Медіана  --- товста лінія всередині скриньки
    + Третій квартиль  --- верхня границя скриньки
    + Максимум --- верхня точка верхнього вуса

- Висота скриньки дорівнює IRQ


## Box plots (2)

- Розгляньмо дані про учасниць бостонського маратону 2001 р.^[Дані з курсу Джима Алберта]

- Подивімося на перші декілька рядків та структуру
```{r marathon, indent = "    "}
boston_marathon <- read_csv("data/boston_marathon.csv")
head(boston_marathon)
str(boston_marathon, give.attr = FALSE)
```

## Box plots (3)

- Можна помітити, що перші рядки присвячено жінкам віком 20 р.

- Розгляньмо інші значення
```{r marathon2, indent = "    "}
table(boston_marathon$age)
```

- Тепер можемо бачити, що в датафреймі є жінки тільки 5 вікових категорій

## Box plots (4)

- Можемо обчислити п'ять підсумкових статистик для часу для 20-річних учасниць
```{r marathon_summary, indent = "    "}
summary(boston_marathon %>% filter(age == 20) %>% .$time)
```

- (Функція `summary` для вектора також додатково рахує середнє аритметичне)

- Як можна бачити, «типовим» значенням є час у 231 хв.
    + (Приблизно) половина жінок пробігла швидше, і (приблизно) половина --- повільніше

- Також робимо висновок, що
    + (Приблизно) чверть жінок пробігла швидше від 222.2 хв.
    + (Приблизно) чверть жінок пробігла від 222.2 до 231 хв. тощо

- Медіана не сильно відрізняється від середнього вибіркового, тому розподіл може бути більш-менш симетричний

## Box plots (5)

- Візуально це можна зобразити за допомогою box plot
```{r marathon_boxplot, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(boston_marathon %>% filter(age == 20), aes(y = time)) +
    geom_boxplot() +
    labs(x = "20-річні жінки", y = "Час пробігу") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- Як можна бачити, розподіл все ж таки не є дуже симетричним, адже вуса мають різну довжину

- Також наявні викиди: одна жінка бігла дуже швидко, декілька --- дуже повільно

- Загалом, можна сформулювати такі принципи:
    + Для симетричного розподілу медіана розташована посередині коробки
    + Вуса мають приблизно однакову довжину
    + Якщо розподіл скошено вправо, то медіана розташована нижче, а верхній вус довший
    + Якщо розподіл скошено вліво, то медіана розташована вище, а нижній вус довший

## Box plots (6)

- Особливо корисним є використання box plots для швидкого порівняння розподілів різних категорій спостережень

- Побудуймо box plots для жінок різних вікових категорій

```{r marathon_boxplot_2, indent = "    ", out.width = "60%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(boston_marathon, aes(x = factor(age), y = time)) +
    geom_boxplot(varwidth = TRUE) +
    labs(x = "Вік", y = "Час пробігу") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '60%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('marathon_boxplot_2', 'pdf'))
```
}

- Параметр `varwidth = TRUE` робить різні скриньки різної ширини, залежно від кількости спостережень у відповідній групі

## Box plots (7)

- Можна зробити такі висновки:
    + Зі збільшенням віку збільшується медіана часу пробігу
    + Впадають у вічі викиди в кожній віковій категорії
    + Три середні вікові категорії мають приблизно однаковий IRQ
    + 20- і 60-річні жінки мають приблизно однаковий IRQ
    + 20-, 30- і 40-річні жінки мають приблизно однакову медіану, тоді як 50- і 60-річні біжать (у середньому) повільніше

- Щоправда, на основі таких візуальних спостережень не варто робити серйозних висновків

- Різниця між віковими категоріями може виявитися статистично незначущою (на це впливає розмір вибірки, форма розподілу тощо)

- Зв'язок між різними змінними не варто сприймати як причиново-наслідковий без додаткового аналізу


## Bar plots (1)

- Якщо ми хочемо візуально оцінити весь розподіл, ми можемо:
    + Для категорійних змінних --- збудувати bar plot
    + Для неперервних змінних --- збудувати гістограму

- Для того, щоб збудувати bar plot, достатньо вказати тільки атрибут естетики `x`

```{r ggplot_bar_plot, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Sex)) +
    geom_bar() +
    labs(x = "Стать пасажира", y = "Кількість") +
    scale_x_discrete(labels = c("Жінка", "Чоловік")) +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '40%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_bar_plot', 'pdf'))
```
}

- Для зміни підписів на графіку ми використали `scale_x_discrete`, яка керує віссю абсцис

- Якщо в `aes` натомість указати `y = Sex`, то стовпчики будуть горизонтальні

## Bar plots (2)

- За замовчуванням `geom_bar` рахує кількість спостережень у кожній категорії

- Якщо ж потрібно просто вивести на графік деякі числа у стовпчастому форматі, то потрібно вказати `y` та додатковий аргумент `stat = "identity"`

```{r ggplot_bar_plot_identity, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE, fig.show = "hide"}
passengers_grouped <- passengers %>% group_by(Sex) %>% summarize(Total = n())

ggplot(passengers_grouped, aes(x = Sex, y = Total)) +
    geom_bar(stat = "identity") +
    labs(x = "Стать пасажира", y = "Кількість") +
    scale_x_discrete(labels = c("Жінка", "Чоловік")) +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '50%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_bar_plot_identity', 'pdf'))
```
}

## Bar plots (3)

- За допомогою bar plots можна відображати спільний розподіл двох категорійних змінних (факторів)

- Для цього потрібно вказати атрибут естетики `fill`
```{r ggplot_bar_plot_stacked_1, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Sex, fill = Survived)) +
    geom_bar() +
    labs(x = "Стать пасажира", y = "Кількість", fill = "Уцілів") +
    scale_x_discrete(labels = c("Жінка", "Чоловік")) +
    scale_fill_discrete(labels = c("Ні", "Так")) +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '50%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_bar_plot_stacked_1', 'pdf'))
```
}

- Такі bar plots називають складеними (stacked)

- Як можна бачити, серед жінок вижила значно більша частка

## Bar plots (4)

- Це, звісно, можна показати і в іншому порядку
```{r ggplot_bar_plot_stacked_2, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE}
ggplot(passengers, aes(x = Survived, fill = Sex)) +
    geom_bar() +
    labs(x = "Уцілів", y = "Кількість", fill = "Стать") +
    scale_x_discrete(labels = c("Ні", "Так")) +
    scale_fill_discrete(labels = c("Жінка", "Чоловік")) +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

## Bar plots (5)

- Варто звернути увагу, що нас цікавить саме атрибут `fill`, а не `color`

- `color` відповідає за колір сторін прямокутиків, і тому є зовсім нецікавим

```{r ggplot_bar_plot_color, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Sex, color = Survived)) +
    geom_bar() +
    labs(x = "Стать пасажира", y = "Кількість", color = "Уцілів") +
    scale_x_discrete(labels = c("Жінка", "Чоловік")) +
    scale_color_discrete(labels = c("Ні", "Так")) +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '50%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_bar_plot_color', 'pdf'))
```
}

## Bar plots (6)

- Альтернативою складеним є так звані згруповані (dodged) діаграми

- Щоб змінити тип діаграми, потрібно уточнити аргумент `position`

- За замовчуванням він дорівнює `stack`

```{r ggplot_bar_plot_dodged, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(passengers, aes(x = Survived, fill = Sex)) +
    geom_bar(position = "dodge") +
    labs(x = "Стать пасажира", y = "Кількість", fill = "Уцілів") +
    scale_x_discrete(labels = c("Жінка", "Чоловік")) +
    scale_fill_discrete(labels = c("Ні", "Так")) +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '50%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_bar_plot_dodged', 'pdf'))
```
}


## Гістограми (1)

- Класичним способом зображення розподілу *неперервних* даних є гістограма

- Розгляньмо відомий [набір даних про діаманти](https://www.kaggle.com/datasets/shivam2503/diamonds)

- Він містить інформацію про ціни та інші характеристики майже 54 000 діамантів
```{r diamonds, indent = "    "}
diamonds <- read_csv("data/diamonds.csv")
str(diamonds, give.attr = FALSE)
```

## Гістограми (2)

- Збудуймо гістограму для ваги діамантів
```{r diamonds_histogram, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(diamonds, aes(x = carat)) +
    geom_histogram() +
    labs(x = "Вага, карат", y = "Кількість") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- За замовчуванням використовується 30 інтервалів (**bins**, дослівно «сміттєвий бак»), тобто `geom_histogram(bins = 30)`

- Як правило, потрібно власноруч підбирати або число інтервалів (`bins = `), або їхню ширину (`binwidth = `)

## Гістограми (3)

- Гістограма дає змогу швидко зрозуміти, наскільки симетричним або скошеним є розподіл у вибірці
    + Як можна бачити з гістограми, розподіл скошений управо

- Інші особливості, на які може звернути увагу гістограма:
    + Викиди (дуже малі або великі значення)
    + Пропуски в даних
    + Наявність декількох кластерів (багатомодальні розподіли)
    + Інші особливості на кшталт нагромадження (bunching)

## Гістограми (4)

- Оскільки даних доволі багато, 30 інтервалів явно недостатньо
```{r diamonds_histogram_bins, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(diamonds, aes(x = carat)) +
    geom_histogram(bins = 500) +
    labs(x = "Вага, карат", y = "Кількість") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- Відразу виникають додаткові питання:
    + Чому вага зосереджена навколо цілих значень каратів та деяких простих дробів?
    + Чому справа від кожного локального максимуму діамантів більше, ніж зліва?
    + Чому так мало діамантів мають вагу більше 3 каратів?

- Маємо справу з декількома *підгрупами* (кластерами) спостережень

- Можна поставити додаткові питання:
    + Чи схожі інші параметри діамантів у рамках одного кластера?
    + Чи відмінні інші параметри діамантів **між** різними кластерами?
    + Чим пояснюється така відмінність?


## Гістограми (5)

- На одному графіку можна зображати декілька гістограм для порівняння
```{r ggplot_histogram_2, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
diamonds <- diamonds %>%
    mutate(cut = factor(cut, levels = c("Fair", "Good", "Very Good", "Premium", "Ideal")))

ggplot(diamonds, aes(x = price, fill = cut)) +
    geom_histogram(bins = 100) +
    labs(x = "Ціна, $", y = "Кількість", fill = "Якість огранки") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

- Ми перетворили змінну `cut` у факторну і вказали правильний порядок категорій (а не за алфавітом)

## Гістограми (6)

- Альтернативно, для спрощення зображення, можна зображати гістограми лінійними графіками
```{r ggplot_histogram_3, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(diamonds, aes(x = price, color = cut)) +
    geom_freqpoly(bins = 100) +
    labs(x = "Ціна, $", y = "Кількість", color = "Тип огранки") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

## Гістограми (7)

- Проте на такому графіку мало що можна побачити, адже в різних категоріях різна кількість спостережень
```{r n, indent = "    "}
diamonds %>% group_by(cut) %>% summarize(total = n())
```

- Тоді доречно не просто рахувати кількість спостережень в інтервалах, а будувати апроксимацію **щільности** (density) розподілу

- Тобто нормалізувати висоту стовпчиків так, щоб сума *площ* дорівнювала 1

## Гістограми (8)

- У нашому контексті це можна зробити за допомогою параметра естетики `y = after_stat(density)`
```{r ggplot_histogram_4, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(diamonds, aes(x = price, y = after_stat(density), color = cut)) +
    geom_freqpoly(bins = 100) +
    labs(x = "Ціна, $", y = "Щільність", color = "Тип огранки") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

- Тепер порівняння можна здійснювати безпосередньо

- Зокрема, можна зробити висновок, що в середньому діаманти з гіршою огранкою мають вищу ціну!
    + Вочевидь, є інші фактори, які впливають на ціну (наприклад, розмір каменя, його вага)

- Взагалі всі розподіли доволі скошені

## Гістограми і викиди (1)

- Розгляньмо гістограму параметра `y` («ширина») діаманта
```{r diamonds_y, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(diamonds, aes(x = y)) +
    geom_histogram(bins = 100) +
    labs(x = "y, мм", y = "Кількість") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- На такій гістограмі важко побачити викиди, хоча вони є (інакше б стільки місця не пустувало)

## Гістограми і викиди (2)

- Можна звузити вікно перегляду за віссю ординат:
```{r diamonds_y2, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(diamonds, aes(x = y)) +
    geom_histogram(bins = 100) +
    labs(x = "y, мм", y = "Кількість") +
    coord_cartesian(ylim = c(0, 20)) +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- Тепер чітко видно, що є три специфічні значення, які можна вважати викидами
    + Діаманти зі значенням `y = 0` не можуть існувати в принципі, і тут вочевидь має місце помилка в самих даних
    + Також сумнівними є діаманти з показником `y`, що перевищує 20 мм

## Гістограми і викиди (3)

- Подивімося, що це за діаманти
```{r diamonds_y3, indent = "    "}
diamonds %>%
    filter(y < 3 | y > 20) %>%
    arrange(y)
```

- Як можна бачити, перші 7 рядків відповідають діамантам, розмір яких у всіх трьох напрямках нульовий (`x = y = z = 0`)

- Що стосується двох останніх, то з високою ймовірністю можна припустити, що замість `31.8` і `58.9` повинно стояти `3.18` та `5.89`

- У таких випадках, як правило, простіше всього **викинути** ці спостереження, бо їх усього 9 на майже 54 000
    + Або ж принаймні замінити дивні значення на `NA`, щоб не викидати весь рядок

- В інших ситуаціях можна провести дальший аналіз **з** та **без** викидів, щоб подивитися, який вони мають вплив

## Трансформація шкали вимірювання (1)

- Якщо дані додатні і сильно скошені, то перед їх візуалізацією корисно перейти до **логаритмічної** шкали (logarithmic scale)

- Розгляньмо дані про щільність населення в кожному штаті США в таких роках: 1960, 1970, 1980, 1990, 2000, 2008 ^[Дані з курсу Джима Алберта]
```{r densities, indent = "    "}
pop_densities <- read_csv("data/pop_densities.csv")
str(pop_densities, give.attr = FALSE)
```

- Нас цікавить аналіз швидкости зміни щільности за відповідний період

## Трансформація шкали вимірювання (2)

- Збудуймо відповідні box plots

- Для цього нам потрібно перетворити дані в охайний формат
    + Наші дані перебувають у так званому **широкому** (wide) форматі (кожний рік має окремий стовпчик)
    + Нам потрібний **довгий** (long) формат, коли під рік відведено окрему змінну, яка може набувати різних значень

- Для перетворення даних в охайний (довгий) формат існує функція `pivot_longer`
```{r pivot_longer, indent = "    "}
pop_densities_long <- pop_densities %>%
   pivot_longer(cols = starts_with("y"),
                names_to = "Year", names_prefix = "y",
                values_to = "Density")
str(pop_densities_long, give.attr = FALSE)
```

- Ми вказали:
    + Які стовпці потрібно перетворити (усі, що починаються на `y`)
    + Як назвати новий стовпець із роками (`names_to = "Year"`)
    + Щоб у цьому стовпці фігурували не назви початкових стовпців типу `y1960`, а числа `1960`, ми вказали `names_prefix = "y"`
    + Як назвати новий стовпець зі значеннями для кожного року (`values_to = "Density"`)

## Трансформація шкали вимірювання (3)

- Власне, самі графіки
```{r density_boxplot, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(pop_densities_long, aes(x = factor(Year), y = Density)) +
    geom_boxplot() +
    labs(x = "Рік", y = "Щільність, осіб / кв. мил.") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- Як можна бачити, ці графіки складно аналізувати:
    + Усі розподіли сильно скошено вправо, і складно розрізнити більшу частину даних, скупчених зліва
    + Наявність дуже великих викидів спотворює всю картину


## Трансформація шкали вимірювання (4)

- Розгляньмо тепер графіки на логаритмічних шкалах
```{r density_boxplot_log, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE}
ggplot(pop_densities_long, aes(x = factor(Year), y = log(Density))) +
    geom_boxplot() +
    labs(x = "Рік", y = "ln(Щільність)") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- Як можна бачити, ситуація суттєво поліпшилася
    + Усі розподіли стали фактично симетричними
    + Оскільки логаритм від дуже великого числа є дуже малим, наявність викидів не настільки принципова
    + IRQ у всіх роках стали дуже близькі

- Зокрема, можна порівняти медіани між собою

## Трансформація шкали вимірювання (5)

- Проте потрібно пам'ятати, що **різниця** логаритмів відповідає **відношенню** початкових даних:
$$
e^{\ln b - \ln a} = \frac{b}{a}
$$

- Тому нас цікавлять такі перетворення:
```{r pop_densities_summary, indent = "    "}
pop_densities_summary <- pop_densities_long %>%
  group_by(Year) %>%
  summarize(med = median(log(Density)), iqr = IQR(log(Density))) %>%
  mutate(med_rat = c(1, exp(diff(med))), iqr_rat = c(1, exp(diff(iqr))))
pop_densities_summary
prod(pop_densities_summary$med_rat)
prod(pop_densities_summary$iqr_rat)
```

- Як можемо бачити, **мультиплікативно** медіани та IQR не сильно змінилися

## Трансформація шкали вимірювання (6)

- Усі міркування стосуються також і гістограм

- Наприклад, можемо прологаритмувати ціну діамантів

```{r ggplot_histogram_log, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggplot(diamonds, aes(x = log(price), y = after_stat(density), color = cut)) +
    geom_freqpoly(bins = 40) +
    labs(x = "Ціна, $", y = "Кількість", color = "Тип огранки") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '40%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('ggplot_histogram_log', 'pdf'))
```
}


- Тепер розподіли стали симетричніші

- Це дає змогу помітити, що для всіх категорій (окрім, хіба що, `Fair`), насправді мають місце два кластери каменів (розподіли бімодальні)

## Особливості застосування QQ-графіків (1)

- Як ми вже знаємо, QQ-графіки можна застосовувати для пошуку викидів
```{r diamonds_qqplot_y, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, cache = TRUE}
library(qqplotr)
diamonds <- slice_sample(diamonds, n = 5000)
ggplot(diamonds, aes(sample = y)) +
    stat_qq_point() + stat_qq_line() + stat_qq_band() +
    labs(x = "Квантилі нормального розподілу", y = "y, мм") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- Бачимо ті самі викиди для змінної `y`, що й раніше

- Також ми додали довірчі інтервали (сірі смуги)
    + Як можна бачити, емпіричні квантилі вибиваються за межі цих інтервалів
    + Це зайве свідчення того, що розподіл не є нормальний

## Особливості застосування QQ-графіків (2)

- Якщо прибрати ці викиди, бачимо таку картину
```{r diamonds_qqplot_y2, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, cache = TRUE}
ggplot(diamonds %>% filter(y > 0 & y < 20), aes(sample = y)) +
    stat_qq_point() + stat_qq_line() + stat_qq_band() +
    labs(x = "Квантилі нормального розподілу", y = "Ціна, $") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- Як можна бачити, змінна `y` має нормальний розподіл тільки посередині

- На хвостах маємо суттєві відхилення:
    + Малі квантилі `y` більші від теоретичних
    + Великі квантилі `y` менші від теоретичних
    + Тобто розподіл `y` **вужчий** від стандартного нормального розподілу

## Особливості застосування QQ-графіків (3)

- Розгляньмо QQ-графік для ціни
```{r diamonds_qqplot_price, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, cache = TRUE}
ggplot(diamonds, aes(sample = price)) +
    stat_qq_point() + stat_qq_line() + stat_qq_band() +
    labs(x = "Квантилі нормального розподілу", y = "Ціна, $") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- Як можна бачити, розподіл не є нормальний

## Особливості застосування QQ-графіків (4)

- Але навіть логаритмування слабко допомагає
```{r diamonds_qqplot_price_log, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, cache = TRUE}
ggplot(diamonds, aes(sample = log(price))) +
    stat_qq_point() + stat_qq_line() + stat_qq_band() +
    labs(x = "Квантилі нормального розподілу", y = "Ціна, $") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```


## Візуалізація двох категорійних змінних (1)

- Якщо обидві змінні категорійні, то можливий варіант зобразити їх такий
```{r diamond_count, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE, cache = TRUE}
ggplot(diamonds, aes(x = cut, y = color)) +
    geom_count() +
    labs(x = "Тип огранки", y = "Колір") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

- Можемо бачити, що більше всього каменів мають колір `G` (ні дуже поганий, ні дуже добрий) в усіх категоріях огранки

## Візуалізація двох категорійних змінних (2)

- Схожу інформацію можна зобразити за допомогою так званої **теплової карти** (heatmap)
```{r diamond_heatmap, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE, cache = TRUE}
ggplot(diamonds %>% count(color, cut), aes(x = cut, y = color, fill = n)) +
    geom_tile() +
    labs(x = "Тип огранки", y = "Колір") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

## Візуалізація двох неперервних змінних (1)

- Чи не найліпший спосіб візуалізації двох неперервних змінних --- scatter plots

- Проте в окремих випадках це може бути не ідеальним рішенням

```{r diamond_scatterplot, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, cache = TRUE, fig.show = "hide"}
ggplot(diamonds, aes(x = carat, y = price)) +
    geom_point() +
    labs(x = " Вага, карат", y = "Ціна, $") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

\visible<+->{
```{r, echo = FALSE, out.width = '40%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('diamond_scatterplot', 'pdf'))
```
}

- Ми бачимо, що існує експоненційна залежність, але оскільки точок дуже багато, вони налізають одна на одну

## Візуалізація двох неперервних змінних (2)

- Можливим поліпшенням є встановлення параметру *прозорости* для точок --- `alpha`, яке лежить від 0 (повністю прозорі) до 1 (повністю непрозорі)
```{r diamond_scatterplot_alpha, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, cache = TRUE}
ggplot(diamonds, aes(x = carat, y = price)) +
    geom_point(alpha = 0.1) +
    labs(x = " Вага, карат", y = "Ціна, $") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20))
```

- Тепер видно, що ціни зростають не зовсім неперервно, а певними стрибками

- Альтернативно можна використати функцію `geom_bin2d`, яка будує «двовимірну гістограму», де кожній прямокутній комірці на площині відповідає кількість спостережень у ній

- Також можна згрупувати значення неперервної змінної в окремі інтервали, фактично перетворивши її в категорійну


## Візуалізація двох неперервних змінних (3)

- Якщо розділити вагу діамантів на інтервали по 0.5 карата, то розподіли ціни будуть такі
```{r diamonds_price_cut, indent = "    ", out.width = "40%", fig.align = "center", warning = FALSE, cache = TRUE}
ggplot(diamonds,
       aes(x = price, y = after_stat(density),
           color = cut(carat, breaks = c(0, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3, max(carat)),
                       include.lowest = TRUE, right = FALSE))) +
    geom_freqpoly(bins = 50) +
    labs(x = "Ціна, $", y = "Щільність", color = "Вага, карат") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20),
          legend.title = element_text(size = 25),
          legend.text = element_text(size = 20))
```

- Розподіли ціни для каменів малої ваги мають приблизно логнормальний розподіл

- Камені середньої ваги мають розподіл, схожий на нормальний

- Камені більше 2 карат вагою мають специфічний розподіл, оскільки їх відносно небагато (1889)

## Візуалізація двох неперервних змінних (4)

- Це можна побачити також на QQ-графіках
```{r diamonds_qqplot_price_cut, indent = "    ", out.width = "60%", fig.align = "center", warning = FALSE, cache = TRUE}
ggplot(diamonds, aes(sample = price)) +
    stat_qq_point() + stat_qq_line() + stat_qq_band() +
    labs(x = "Ціна, $", y = "Щільність") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20)) +
    facet_wrap(~ cut(carat,
                     breaks = c(0, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3, max(carat)),
                     include.lowest = TRUE, right = FALSE))
```

## Візуалізація двох неперервних змінних (5)

- Можемо застосувати логаритм до перших трьох вагових категорій
```{r diamonds_qqplot_price_cut_3, indent = "    ", out.width = "60%", fig.align = "center", warning = FALSE, cache = TRUE}
ggplot(diamonds %>% filter(carat < 1), aes(sample = log(price))) +
    stat_qq_point() + stat_qq_line() + stat_qq_band() +
    labs(x = "Ціна, $", y = "Щільність") +
    theme(axis.title = element_text(size = 25),
          axis.text = element_text(size = 20)) +
    facet_wrap(~ cut(carat,
                     breaks = c(0, 0.5, 0.75, 1),
                     include.lowest = TRUE, right = FALSE))
```

- Як бачимо, застосування логаритма зробило розподіл більш нормальним

## Зображення кореляцій між різними змінними (1)

- Як відомо з теорії ймовірностей, корисною властивістю спільного розподілу двох випадкових величин $X$ та $Y$ є їх **коваріація** (covariance):
\[
\Cov{X}{Y} \equiv \sigma_{XY} = \EE{(X - \EE{X})(Y - \EE{Y})} = \EE{XY} - \EE{X}\EE{Y}
\]
- Варто згадати, що замість **дисперсії** (variance) $\Var{X}$ ми використовуємо середньоквадратичне відхилення $\sigma_X = \sqrt{\Var{X}}$
    + Воно має ті ж одиниці виміру, що й $X$

- Аналогічно, $\Cov{X}{Y}$ має інші одиниці виміру, аніж $X$ чи $Y$, тому доцільно перейти до **коефіцієнта кореляції** (correlation):
\[
\Corr{X}{Y} \equiv \rho_{XY} = \frac{\Cov{X}{Y}}{\sqrt{\Var{X}\Var{Y}}}
\]

- Його також називають **коефіцієнтом кореляції Пірсона**^[Карл Пірсон --- англійський математик (Karl Pearson, 1857--1936)]

- Коефіцієнт кореляції є безрозмірною величиною і завжди $\rho_{XY} \in [-1; 1]$


## Зображення кореляцій між різними змінними (2)

- Коваріація двох випадкових величин $\Cov{X}{Y}$ показує ступінь **лінійного** зв'язку між ними

- Якщо $\Cov{X}{Y} > 0$, то між величинами існує **додатний** лінійний зв'язок, тобто більші значення однієї величини свідчать про більші значення іншої

- Якщо $\Cov{X}{Y} < 0$, то між величинами існує **від'ємний** лінійний зв'язок, тобто більші значення однієї величини свідчать про менші значення іншої

- Якщо $\Cov{X}{Y} = 0$, то лінійного зв'язку між величинами немає

- Те саме можна сказати про $\Corr{X}{Y}$

- Понад те, що ближчі за модулем до 1 значення $\Corr{X}{Y}$, то сильніша лінійна залежність

## Зображення кореляцій між різними змінними (3)

- Очевидною оцінкою коефіцієнта кореляції є статистика, де замість коваріації та дисперсії використано їхні вибіркові аналоги

- Нехай маємо вибірку $\left((X_1, Y_1)^\top, \ldots, (X_n, Y_n)^\top\right)$  таку, що $(X_i, Y_i)^\top$ незалежні і мають однаковий розподіл

- Тоді
\[
\hat{\rho}_{XY} = \frac{\sum_{i=1}^n \left(X_i - \overline{X}\right)\left(Y_i - \overline{Y}\right)}{\sqrt{\sum_{i=1}^n \left(X_i - \overline{X}\right)^2\sum_{i=1}^n \left(Y_i - \overline{Y}\right)^2}}
\]

- В R коефіцієнт кореляції можна обчислити за допомогою функції `cor`

## Зображення кореляцій між різними змінними (4)

- А візуалізувати як **корелограму** (correlogram) можна за допомогою спеціальної функції з пакета `GGally`
```{r passengers_ggally, indent = "    ", out.width = "70%", fig.align = "center", warning = FALSE}
ggcorr(passengers %>% select(where(is.numeric)), label = TRUE)
```

- Як можна бачити, особливо сильної кореляції між змінними немає

## Зображення кореляцій між різними змінними (5)

- Інша корисна функція з цього пакета показує не тільки кореляції, а й попарні scatter plots, box plots, гістограми тощо
```{r passengers_ggally2, indent = "    ", out.width = "60%", fig.align = "center", warning = FALSE, message = FALSE}
ggpairs(passengers %>% select(where(is.numeric) | where(is.factor)),
        diag = list(continuous = "barDiag", discrete = "barDiag", na = "naDiag"))
```

- Використовуючи аргументи `upper`, `lower` та `diag`, можна вказувати, які саме візуалізації використовувати для неперервних та категорійних змінних



## Зображення кореляцій між різними змінними (6)

- Коефіцієнт кореляції Пірсона свідчить тільки про наявність лінійного зв'язку між випадковими величинами

- Як існує не лінійний, *але монотонний* зв'язок, то можна натомість використати **коефіцієнт кореляції Спірмана** (Spearman correlation)^[Чарльз Спірман --- британський психолог (Charles Edward Spearman, 1863--1945)]
    + Для цього треба у функції `cor` вказати `method = "spearman"`
    + ...а у функції `ggcorr` --- `method = c("pairwise", "spearman")`
```{r passengers_ggally_spearman, indent = "        ", out.width = "40%", fig.align = "center", warning = FALSE, fig.show = "hide"}
ggcorr(passengers %>% select(where(is.numeric)), label = TRUE,
       method = c("pairwise", "spearman"))
```

\visible<+->{
```{r, echo = FALSE, out.width = '40%', fig.align = 'center'}
knitr::include_graphics(knitr::fig_chunk('passengers_ggally_spearman', 'pdf'))
```
}

- Коефіцієнт кореляції Спірмана --- це просто коефіцієнт кореляції Пірсона, але між *порядковими номерами відсортованих* $X_i$ та $Y_i$

- Він стійкіший до наявности викидів

## Зображення кореляцій між різними змінними (7)

- Також коефіцієнт кореляції Спірмана можна застосовувати до категорійних змінних, які є **впорядкованими** (ordered)
```{r passengers_ggally_spearman_ordered, indent = "    ", out.width = "50%", fig.align = "center", warning = FALSE}
ggcorr(passengers %>% select(where(is.numeric) | where(is.ordered)) %>%
           mutate(Pclass = as.numeric(Pclass)), label = TRUE, method = c("pairwise", "spearman"))
```

- Як можна бачити, `Fare` і `Pclass` мають посутню від'єму кореляцію, що цілком очікувано

- Також слабенька від'ємна кореляція існує між `Pclass` та `Age`

## Принципи добрих аналітичних графіків

- Розгляньмо 6 принципів побудови інформативних та корисних графіків, описаних Едвардом Тафті (Edward Tufte) у книжці *Beautiful Evidence*

1. Демонструвати на графіку порівняння, наприклад, box plots для різних категорій чи фацетовані гістограми тощо

2. Зображати на графіку механізмів, які пояснюють, чому ми спостерігаємо ту чи ту картину

3. Показувати на графіку декілька змінних одночасно (використовуючи кольори, розмір і форму точок тощо)

4. Використовувати на графіку, за потреби, текстові мітки, числа тощо

5. Вказувати підписи осей, шкали вимірювань, промовисту назву, авторів чи використаних джерел тощо

6. Фокусуватися на контенті графіка, а не на дизайнерських рішеннях

- Приклади неякісних графіків та типових помилок можна проглянути [тут](https://www.datapine.com/blog/misleading-data-visualization-examples/) і [тут](https://www.jotform.com/blog/bad-data-visualization/)





<!-- Які джерела ще проглянути: -->
<!-- EDA checklists in "Art of Data Science" -->



